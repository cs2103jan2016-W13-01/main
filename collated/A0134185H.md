# A0134185H
###### bin\document\help.txt
``` txt
DIAMOND HELP LIST

{
Command: add
Adds a new task. Tasks can belong to 4 types: deadline, session, float and recurring tasks

Format for float:
>> add [title]
Example:
>> add watch The Avengers

Format for deadline:
>> add [title] [time][date in MM/dd/yyyy]
Example:
>> add Lunch with family 1pm 04/01/2016
Hint:
- deadline can also refer to tasks you want to do at a moment but has no end time
- date can also be "tomorrow", "next tuesday", "tmr". If date is empty, it is treated as today

Format for session:
>> add [title] from [start time][date] to [end time][date]
Example:
>> add Meeting with project team from 2pm tmr to 4pm tmr
Hint:
- the template "from...to..." can be shortened to "...to..." or "... - ..."
- "add Meeting with project team tmr 2pm-4pm will" means the start and end dates are the same

Format for recurring:
>> add [title] from [start time][date] to [end time][date] every [number] [day/week/month/year]
Or:
>> add [title] [time][date] every [number] [day/week/month/year]
Example:
>> add Meeting with project team from 2pm-4pm tmr every week
>> add Take shower 8pm every day
}

{
Command: delete
Deletes an entry from the list
Format:
>> delete [task number]
Example:
>> delete 1
}

{
Command: edit
Edits an existing entry
Format:
>> edit [task number] [task title] [time][date] [time][date] [recurring period]
Example:
>> edit 1 Lunch with family 12.30pm 04/02/2016
Hint:
- if you leave a field blank, that field will stay the same as in the unedited task
- you can make a float task into a deadline by specify its time
- you can make a non-recurring task into a recurring one by giving period
}

{
Command: search
Searches for specific entries using a set of keywords
Format:
>> search [keyword1] [keyword2]...
Example:
>> search family dinner
}

{
Command: sort
As you can see, our tasks are sorted automatically in choronological order.
}

{
Command: undo
Undo the last action
Format:
>> undo
Hint:
- you can undo multiple times
}

{
Command: redo
Redo the last undone action
Format:
>> redo
Hint:
- you can redo multiple times
}

{
Command: display
Display the tasks in various pre-defined categories
Format:
>> display [category]
Example:
>> display all
Available categories:
all, completed, incomplete, upcoming, deadline, float, session, recurring
}

{
Category: all
All tasks, including those done and not done, in all types. Excluding the deleted ones however
}

{
Category: completed
All tasks that are marked as done
}

{
Category: incomplete
All tasks that are yet to be marked done
}

{
Category: upcoming
All tasks that occur today and tomorrow with respect to the current date
}

{
Category: deadline
All deadlines, meaning tasks that have only one time
}

{
Category: session
All sessions, meaning tasks that have starting and ending times
}

{
Category: float
All floating tasks, meaning tasks that have no time
}

{
Category: recurring
All recurring tasks, meaning tasks that have a recurring period
}
```
###### src\document\help.txt
``` txt
DIAMOND HELP LIST

{
Command: add
Adds a new task. Tasks can belong to 4 types: deadline, session, float and recurring tasks

Format for float:
>> add [title]
Example:
>> add watch The Avengers

Format for deadline:
>> add [title] [time][date in MM/dd/yyyy]
Example:
>> add Lunch with family 1pm 04/01/2016
Hint:
- deadline can also refer to tasks you want to do at a moment but has no end time
- date can also be "tomorrow", "next tuesday", "tmr". If date is empty, it is treated as today

Format for session:
>> add [title] from [start time][date] to [end time][date]
Example:
>> add Meeting with project team from 2pm tmr to 4pm tmr
Hint:
- the template "from...to..." can be shortened to "...to..." or "... - ..."
- "add Meeting with project team tmr 2pm-4pm will" means the start and end dates are the same

Format for recurring:
>> add [title] from [start time][date] to [end time][date] every [number] [day/week/month/year]
Or:
>> add [title] [time][date] every [number] [day/week/month/year]
Example:
>> add Meeting with project team from 2pm-4pm tmr every week
>> add Take shower 8pm every day
}

{
Command: delete
Deletes an entry from the list
Format:
>> delete [task number]
Example:
>> delete 1
}

{
Command: edit
Edits an existing entry
Format:
>> edit [task number] [task title] [time][date] [time][date] [recurring period]
Example:
>> edit 1 Lunch with family 12.30pm 04/02/2016
Hint:
- if you leave a field blank, that field will stay the same as in the unedited task
- you can make a float task into a deadline by specify its time
- you can make a non-recurring task into a recurring one by giving period
}

{
Command: search
Searches for specific entries using a set of keywords
Format:
>> search [keyword1] [keyword2]...
Example:
>> search family dinner
}

{
Command: sort
As you can see, our tasks are sorted automatically in choronological order.
}

{
Command: undo
Undo the last action
Format:
>> undo
Hint:
- you can undo multiple times
}

{
Command: redo
Redo the last undone action
Format:
>> redo
Hint:
- you can redo multiple times
}

{
Command: display
Display the tasks in various pre-defined categories
Format:
>> display [category]
Example:
>> display all
Available categories:
all, completed, incomplete, upcoming, deadline, float, session, recurring
}

{
Category: all
All tasks, including those done and not done, in all types. Excluding the deleted ones however
}

{
Category: completed
All tasks that are marked as done
}

{
Category: incomplete
All tasks that are yet to be marked done
}

{
Category: upcoming
All tasks that occur today and tomorrow with respect to the current date
}

{
Category: deadline
All deadlines, meaning tasks that have only one time
}

{
Category: session
All sessions, meaning tasks that have starting and ending times
}

{
Category: float
All floating tasks, meaning tasks that have no time
}

{
Category: recurring
All recurring tasks, meaning tasks that have a recurring period
}
```
###### src\logic\tasks\TaskUtil.java
``` java
	public static Task parseFromStorage(String entry) {
		
		String[] parts = entry.split(FIELD_SEPARATOR);
		for (String str: parts) {
			System.out.println(str);
		}
		String titleString = parts[0].split(":", 2)[1].trim();
		
		Calendar startDate;
		Calendar endDate;
		
		try {
			String startDateString = parts[1].split(":", 2)[1].trim();
			startDate = parseDate(startDateString);
		} catch (IndexOutOfBoundsException e) {
			startDate = null;
		}
		
		try {
			String endDateString = parts[2].split(":", 2)[1].trim();
			endDate = parseDate(endDateString);
		} catch (IndexOutOfBoundsException e) {
			endDate = null;
		}
		
		int period;
		try {
			String periodString = parts[3].split(":", 2)[1].trim();
			period = Integer.parseInt(periodString);
		} catch (NumberFormatException e) {
			period = 0;
		} catch (IndexOutOfBoundsException e) {
			period = 0;
		}
		
		boolean isDone;
		try {
			String statusString = parts[4].split(":", 2)[1].trim();
			isDone = statusString.equals("completed");
		} catch (IndexOutOfBoundsException e) {
			isDone = false;
		}
		
		boolean isRecurrence;
		try {
			String isRecurrenceString = parts[5].split(":", 2)[1].trim();
			isRecurrence = isRecurrenceString.equals("true");
		} catch (IndexOutOfBoundsException e) {
			isRecurrence = false;
		}
		Task result = getInstance(titleString, startDate, endDate, period);
		result.setDone(isDone);
		result.setRecurrence(isRecurrence);
		return result;
	}
	
	public static Calendar parseDate(String dateString) {
		if (dateString.equals(NULL_TIME)) {
			return null;
		} else {
			Calendar cal = Calendar.getInstance();
			SimpleDateFormat format = new SimpleDateFormat("HH:mm yyyyMMdd", Locale.ENGLISH);
			try {
				cal.setTime(format.parse(dateString));
				return cal;
			} catch (ParseException e) {
				return null;
			}
		}
	}
	
	public static String convertFromDate(Calendar date, DateFormat format) {
		if (date == null) {
			return NULL_TIME;
		} else {
			return format.format(date.getTime());
		}
	}
	
	public static String convertToStorage(Task task) {
		StringBuilder sb = new StringBuilder();
		sb.append("title: " + task.getTitle() + FIELD_SEPARATOR + "\r\n");
		String startDateString, endDateString, statusString, isRecurrenceString;
		startDateString = convertFromDate(task.getStartDate(), STORAGE_FORMAT);
		endDateString = convertFromDate(task.getEndDate(), STORAGE_FORMAT);
		statusString = (task.isDone())? "completed":"incomplete";
		isRecurrenceString = (task.isRecurrence())? "true":"false";
		int period = task.getPeriod();
		sb.append("start: " + startDateString + FIELD_SEPARATOR + "\r\n");
		sb.append("end: " + endDateString + FIELD_SEPARATOR + "\r\n");
		sb.append("recurring period: " + period + FIELD_SEPARATOR + "\r\n");
		sb.append("status: " + statusString + FIELD_SEPARATOR + "\r\n");
		sb.append("is recurrence: " + isRecurrenceString + FIELD_SEPARATOR + "\r\n");
		return sb.toString();
	}
	
	public static String[] toStringArray(Task task) {
		String isDoneString = task.isDone() ? "complete" : "incomplete";
		String titleString = task.getTitle();
		String startString = convertFromDate(task.getStartDate(), DISPLAY_FORMAT);
		String endString;
		if (task instanceof Session) {
			endString = convertFromDate(((Session) task).getEndDate(), DISPLAY_FORMAT);
		} else if (task instanceof RecurringTask) {
			endString = convertFromDate(((RecurringTask) task).getEndDate(), DISPLAY_FORMAT);
		} else {
			endString = NULL_TIME;
		}
		String periodString;
		if (task instanceof RecurringTask) {
			periodString = Integer.toString(((RecurringTask) task).getPeriod());
		} else {
			periodString = NULL_TIME;
		}
		String[] result = {isDoneString, titleString, startString, endString, periodString};
		return result;
	}
	
	
	public static String toString(Task task) {
		String isDoneString = task.isDone() ? "complete" : "incomplete";
		String titleString = task.getTitle();
		String startString = convertFromDate(task.getStartDate(), DISPLAY_FORMAT);
		String endString;
		if (task instanceof Session) {
			endString = convertFromDate(((Session) task).getEndDate(), DISPLAY_FORMAT);
		} else if (task instanceof RecurringTask) {
			endString = convertFromDate(((RecurringTask) task).getEndDate(), DISPLAY_FORMAT);
		} else {
			endString = NULL_TIME;
		}
		String periodString;
		if (task instanceof RecurringTask) {
			periodString = ((RecurringTask) task).getPeriodString();
		} else {
			periodString = NULL_TIME;
		}
		String result = isDoneString + "; " + titleString + "; "
						+ startString + "; " + endString + "; " + periodString;
		return result;
	}
	
```
###### src\storage\Storage.java
``` java

package storage;

import java.util.*;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.logging.Logger;

import logic.tasks.*;

import java.io.*;
import java.nio.file.Files;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;

public class Storage {

	private static final String CONFIG_FILE_NAME = "./src/document/config.txt";
	private static File configFile;
	
	private static String storageFileName;
	private static File storageFile;
	private static ArrayList<Deadline> taskList;
	private static ArrayList<Integer> indexList;
	private static Logger logger = Logger.getLogger(Storage.class.getName());
	private static int floatBeginOnTaskList;
	private static int floatBeginOnIndexList;
	
	public static Deadline latestDeletedTask;
	public static int latestDeletedIndex;

	private Storage() throws IOException, ClassNotFoundException {
		retrieveFile();
		taskList = loadTaskList();
	}
	
	public static ArrayList<Deadline> getTaskList() {
		return taskList;
	}
	
	public static ArrayList<Integer> getIndexList() {
		return indexList;
	}
	
	public static int getFloatBegin() {
		return floatBeginOnTaskList;
	}
	
	public static int getFloatBeginOnIndexList() {
		return floatBeginOnIndexList;
	}

	public static File retrieveFile() throws IOException {
		
		configFile = new File(CONFIG_FILE_NAME);
		Scanner sc = new Scanner(configFile);
		storageFileName = sc.nextLine();
		sc.close();
		
		storageFile = new File(storageFileName);
		if (!storageFile.exists()) {
			// Create file if it does not exist
			storageFile.createNewFile();
		}
		return storageFile;
	}

	// appends a new line of text at the bottom of the file
<<<<<<< HEAD:src/Storage/Storage.java
	public static ArrayList<Integer> addNewTask(Task newTask) throws IOException {
=======
	public static ArrayList<Integer> addNewTask(Deadline newTask) throws IOException {
>>>>>>> db62cdf23ac4ee1c89c10432c6a7ce47ac83eab4:src/storage/Storage.java

		logger.log(Level.INFO, "Adding new Task to the ArrayList");
		assert (taskList != null) : "taskList not initialized";
		assert (newTask != null) : "task is null";
		if (newTask.getDateString().equals("")) {
			taskList.add(newTask);
		} else {
			taskList.add(floatBeginOnTaskList, newTask);
			floatBeginOnTaskList++;
		}
		saveTaskList();
		//indexList.add(taskList.size());
		displayAllTasks();
		
		return indexList;
	}
	public static ArrayList<Integer> addNewTask(Deadline newTask, int taskListPosition) throws IOException {

		logger.log(Level.INFO, "Adding new Task to the ArrayList at position: " + taskListPosition);
		taskList.add(taskListPosition, newTask);
		if (newTask.getDate() != null) {
			floatBeginOnTaskList++;
		}
		saveTaskList();
		displayAllTasks();
		return indexList;
	}

	// deletes a line from the file based on line number
	public static Deadline deleteTask(int deleteIndex) throws IOException {

		assert (deleteIndex >= 0);

		if (!taskList.isEmpty() && deleteIndex <= taskList.size()) {
			logger.log(Level.INFO, "Deleting Task from the ArrayList");
			latestDeletedTask = taskList.remove(deleteIndex);
			if (deleteIndex < floatBeginOnTaskList) {
				floatBeginOnTaskList--;
			}
			saveTaskList();
			latestDeletedIndex = indexList.indexOf(new Integer(deleteIndex));
			indexList.remove(latestDeletedIndex);
			if (latestDeletedIndex < floatBeginOnIndexList) {
				floatBeginOnIndexList--;
			}
			for (int i = latestDeletedIndex; i < indexList.size(); i++) {
				indexList.set(i, indexList.get(i) - 1);
			}
		}
		return latestDeletedTask;
	}
	
	public static Deadline deleteTask(Deadline taskToDelete) throws IOException {
		
		assert taskToDelete != null: "Attempt to delete a null task";
		if (taskList.contains(taskToDelete)) {
			taskList.remove(taskToDelete);
			saveTaskList();
		} else {
			throw new Error("Task not found in task list");
		}
		return taskToDelete;
	}

	// deletes all text in the file
	public static boolean clearAllTasks() {
		try {
			logger.log(Level.INFO, "Deleting ALL Tasks from the ArrayList");
			taskList.clear();
			indexList.clear();
			floatBeginOnTaskList = 0;
			floatBeginOnIndexList = 0;
			clearStorageFile();
			return true;
		} catch (IOException e) {
			return false;
		}
	}
	
	static void clearStorageFile() throws IOException {
		Files.delete(storageFile.toPath()); // delete the whole file and
		storageFile.createNewFile(); // create a new empty file with the
										// same name
	}

	public static void setPath(String pathName) throws IOException{
		configFile.delete();
		configFile.createNewFile();
		BufferedWriter bf = initBufferedWriter(configFile);
		bf.write(pathName);
		bf.newLine();
		bf.close();
		retrieveFile();
		saveTaskList();
	}
	
	public static String getPath() {
		return storageFile.toPath().toString();
	}

	public static void sortTasks() throws IOException {
		File tempStorageFile = new File("tempStorageFile.txt");
		BufferedReader sortBufferedReader = initBufferedReader(storageFile);
		BufferedWriter sortBufferedWriter = initBufferedWriter(tempStorageFile);
		String line;
		ArrayList<String> textList = new ArrayList<String>();
		while ((line = sortBufferedReader.readLine()) != null) {
			textList.add(line);
		}
		Collections.sort(textList, String.CASE_INSENSITIVE_ORDER);
		for (String output : textList) {
			sortBufferedWriter.write(output);
			sortBufferedWriter.newLine();
		}
		sortBufferedReader.close();
		sortBufferedWriter.close();
		storageFile.delete();
		tempStorageFile.renameTo(storageFile);
	}

	public static ArrayList<Integer> searchTask(Predicate<Deadline> p) {

		indexList.clear();
		int i;
		logger.log(Level.INFO, "Storing all hits indices in the indexList");
		for (i = 0; i < floatBeginOnTaskList; i++) {
			Deadline task = taskList.get(i);
			if (p.test(task)) {
				indexList.add(i);
			}
		}
		floatBeginOnIndexList = indexList.size();
		for (i = floatBeginOnTaskList; i < taskList.size(); i++) {
			Deadline task = taskList.get(i);
			if (p.test(task)) {
				indexList.add(i);
			}
		}
		return indexList;
	}
	
	public static ArrayList<Integer> displayAllTasks() {
		indexList.clear();
		for (int i = 0; i < taskList.size(); i++) {
			indexList.add(i);
		}
		floatBeginOnIndexList = floatBeginOnTaskList;
		return indexList;
	}

	private static BufferedReader initBufferedReader(File textFile) throws FileNotFoundException {
		FileReader fileReader = new FileReader(textFile.getAbsoluteFile());
		BufferedReader bufferedReader = new BufferedReader(fileReader);
		return bufferedReader;
	}

	private static BufferedWriter initBufferedWriter(File textFile) throws IOException {
		FileWriter fileWriter = new FileWriter(textFile.getAbsoluteFile(), true);
		BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
		return bufferedWriter;
	}

	public static ArrayList<Deadline> loadTaskList() throws ClassNotFoundException, IOException {

	/*	taskList = new ArrayList<Task>();
		BufferedReader br = new BufferedReader(new FileReader(storageFile));
		if (br.readLine() == null) {
			br.close();
		} else {
			FileInputStream fis = new FileInputStream(storageFile);
			ObjectInputStream ois = new ObjectInputStream(fis);
			taskList = (ArrayList<Task>) ois.readObject();
			ois.close();
		}
		return taskList;
		*/
		
		BufferedReader br = initBufferedReader(storageFile);
		taskList = new ArrayList<Deadline>();
		floatBeginOnTaskList = 0;
			
		String titleString, dateString;
		while((titleString = br.readLine()) != null && (dateString = br.readLine()) != null) {
			try {
				DateFormat df = new SimpleDateFormat("HH:mm:ss yyyyMMdd", Locale.ENGLISH);
				Date date;
				if (dateString.equals("null")) {
					date = null;
				} else {
					date = df.parse(dateString);
					floatBeginOnTaskList++;
				}
				Deadline task = new Deadline(titleString.trim(), date);
				taskList.add(task);
			} catch (ParseException e) {
				e.printStackTrace();
			}
		}
		br.close();
		return taskList;
	}

	private static void saveTaskList() throws IOException {
	/*	FileOutputStream fos = new FileOutputStream(storageFile);
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		oos.writeObject(taskList);
		oos.close();
	*/
		clearStorageFile();
		BufferedWriter bw = initBufferedWriter(storageFile);
		DateFormat df = new SimpleDateFormat("HH:mm:ss yyyyMMdd");
		for (int i = 0; i < taskList.size(); i++) {
			Deadline task = taskList.get(i);
			bw.write(task.getTitle());
			bw.newLine();
			Date date = task.getDate();
			String dateString;
			if (date == null) {
				dateString = "null";
			} else {
				dateString = df.format(date);
			}
			bw.write(dateString);
			bw.newLine();
		}
		bw.close();
	}
	
	public static void initialize() throws ClassNotFoundException, IOException {
		retrieveFile();
		loadTaskList();
		initIndexList();
	}

	private static void initIndexList() {
		indexList = new ArrayList<Integer>();
		displayAllTasks();
	}
}
```
###### Test\IntegratedTestRunner.java
``` java
public class IntegratedTestRunner {
	private static final String inputDirName = "./Test/input";
	private static final String outputDirName = "./Test/actual";
	private static final String expectedDirName = "./Test/expected";
	
	public static void runTest(String inputFileName) throws IOException {
		TextUI.initialize();
		StorageController.clearAllTasks();
		File inputDir = new File(inputDirName);
		if (!inputDir.exists()) {
			inputDir.mkdirs();
		}
		File outputDir = new File(outputDirName);
		if (!outputDir.exists()) {
			outputDir.mkdirs();
		}
		File expectedDir = new File(expectedDirName);
		if (!expectedDir.exists()) {
			expectedDir.createNewFile();
		}		
		File expectedFile = new File(expectedDirName + "/" + inputFileName + ".expected");
		if (!expectedFile.exists()) {
			expectedFile.createNewFile();
		}
		File inputFile = new File(inputDirName + "/" + inputFileName);
		File outputFile = new File(outputDirName + "/" + inputFileName + ".actual");
		outputFile.delete();
		outputFile.createNewFile();
		TextUI.mainFileToFile(inputFile, outputFile);
		String output = FileUtils.readFileToString(outputFile, "UTF-8");
		String expected = FileUtils.readFileToString(expectedFile, "UTF-8");
		assertEquals(expected, output);
	}
	
	/*
	public static File getExpectedFile(String expectedFileName) throws IOException {
		File expectedDir = new File(expectedDirName);
		if (!expectedDir.exists()) {
			expectedDir.createNewFile();
		}
		
		File expectedFile = new File(expectedDirName + "/" + expectedFileName);
		if (!expectedFile.exists()) {
			expectedFile.createNewFile();
		}
		return expectedFile;
	}
	*/
}
```
###### Test\testAddAndDelete.java
``` java
public class testAddAndDelete {
		
	@Test
	public void test() throws IOException {
		/*
		String output = FileUtils.readFileToString(IntegratedTestRunner.runTest("in1.txt"), "UTF-8");
		String expected = FileUtils.readFileToString(IntegratedTestRunner.getExpectedFile("in1.txt.expected"), "UTF-8");
		assertEquals(expected, output);
		*/
		IntegratedTestRunner.runTest("in1.txt");
	}
}
```
###### Test\testAddDifferentTime.java
``` java
			
	@Test
	public void test() throws IOException {
		/*
		String output = FileUtils.readFileToString(IntegratedTestRunner.runTest("in1.txt"), "UTF-8");
		String expected = FileUtils.readFileToString(IntegratedTestRunner.getExpectedFile("in1.txt.expected"), "UTF-8");
		assertEquals(expected, output);
		*/
		IntegratedTestRunner.runTest("in3.txt");
	}
}
```
###### Test\testDeleteAndUndo.java
``` java
			
	@Test
	public void test() throws IOException {
		/*
		String output = FileUtils.readFileToString(IntegratedTestRunner.runTest("in1.txt"), "UTF-8");
		String expected = FileUtils.readFileToString(IntegratedTestRunner.getExpectedFile("in1.txt.expected"), "UTF-8");
		assertEquals(expected, output);
		*/
		IntegratedTestRunner.runTest("in2.txt");
	}
}
```
###### Test\testEdit.java
``` java
			
	@Test
	public void test() throws IOException {
		/*
		String output = FileUtils.readFileToString(IntegratedTestRunner.runTest("in1.txt"), "UTF-8");
		String expected = FileUtils.readFileToString(IntegratedTestRunner.getExpectedFile("in1.txt.expected"), "UTF-8");
		assertEquals(expected, output);
		*/
		IntegratedTestRunner.runTest("in4.txt");
	}
}
```
###### Test\TestUndoAndRedo.java
``` java
			
	@Test
	public void test() throws IOException {
		/*
		String output = FileUtils.readFileToString(IntegratedTestRunner.runTest("in1.txt"), "UTF-8");
		String expected = FileUtils.readFileToString(IntegratedTestRunner.getExpectedFile("in1.txt.expected"), "UTF-8");
		assertEquals(expected, output);
		*/
		IntegratedTestRunner.runTest("in5.txt");
	}
}
```
