# A0121535R
###### src\logic\commands\CommandHelp.java
``` java
 * This class contains details for help commands
 */
public class CommandHelp implements Command{
	public CommandType getType() {
		return CommandType.HELP;
	}
	
	public String execute() {
		return null;
	}
	
	public String undo() {
		return null;
	}

}
```
###### src\Parser\AddParser.java
``` java
* Parser for adding a task
*/
import java.util.logging.Level;

import logic.Priority;
import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandInvalid;
import logic.tasks.Task;

public class AddParser extends GeneralParser {
	
	public Command parse(String inputArgs){
		try{
		String title = getTitle(inputArgs);
		Calendar[] date = getDateArray(inputArgs);
		Priority tag = getTag(inputArgs);
		int recurring = getRecurring(inputArgs);
		Task task = createTask(title,date,tag,recurring);
		Command cmdDetails = new CommandAdd(task);
		
		//String description = getDescription(inputArgs);
		return cmdDetails;

		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}
		
	}
}
```
###### src\Parser\CommandParser.java
``` java
 * inital parser that sort the input to the respective parser classes
 */
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import logic.commands.Command;
import logic.commands.CommandClear;
import logic.commands.CommandDisplay;
import logic.commands.CommandHelp;
import logic.commands.CommandInvalid;
import logic.commands.CommandMark;
import logic.commands.CommandRedo;
import logic.commands.CommandType;
import logic.commands.CommandUndo;
import logic.commands.CommandUnmark;

public class CommandParser {

	public static Logger parserLogger = Logger.getLogger(CommandParser.class.getName());
	public ArrayList<String> list;
	public static SimpleDateFormat sdf;

	public static CommandParser cmdParser;
	FileHandler fh; 

	public CommandParser() throws SecurityException, IOException {
		list = new ArrayList<String>();
		sdf = new SimpleDateFormat("ddMMyyyy HHmm");
		sdf.setLenient(false);
		FileHandler fh = new FileHandler("./log/MyLogFile.txt");  
		parserLogger.addHandler(fh);
		System.out.println("where is my log file "+getClass().getClassLoader().getResource("logging.properties"));
		parserLogger.log(Level.INFO, "log starting");

	}


	public static CommandParser getInstance() throws SecurityException, IOException{
		if (cmdParser == null){
			cmdParser= new CommandParser();
		}
		return cmdParser;
	}

	/**for add
	 * Requires input format <add> <title> <date> 
	 * for e.g add meet at john's house at next wednesday
	 * 
	 * for delete
	 * Requires input format <delete> <num>
	 * for e.g delete 2
	 * 
	 * for edit
	 * Requires input format <edit> <num> <title>/<date>
	 * for e.g edit 3 meet at jack's place 
	 * or edit 3 at next tuesday
	 * should check the value of TASK to see if the respective title and date fields 
	 * are null or not.
	 * 
	 * for mark
	 * Requires input format <mark> <num>
	 * for e.g mark 1
	 * 
	 * for unmark
	 * Requires input format <unmark> <num>
	 * for e.g unmark 1
	 * 
	 * for undo
	 * inputformat <undo>
	 */
	public static Command parseInput(String input) {
		String[] inputTokens = getToken(input);
		CommandType cmd = getCmdType(inputTokens[0]);
		Command cmdDetails;
		if(inputTokens.length==2){
			switch(cmd){

				case ADD:
					AddParser ap = new AddParser();
					return cmdDetails = ap.parse(inputTokens[1]);

				case DELETE:
					DeleteParser dp = new DeleteParser();
					return cmdDetails = dp.parse(inputTokens[1]);

				case EDIT:
					EditParser ep = new EditParser();
					return cmdDetails = ep.parse(inputTokens[1]);

				case MARK:
					int inputNum = getInputNum(inputTokens[1]);
					if(inputNum==-1){
						cmd=CommandType.INVALID;
					}
					return cmdDetails= new CommandMark(inputNum);

				case UNMARK:
					inputNum = getInputNum(inputTokens[1]);
					if(inputNum==-1){
						cmd=CommandType.INVALID;
					}
					return cmdDetails= new CommandUnmark(inputNum);

				case SET:
					SetParser setParser = new SetParser();
					return cmdDetails = setParser.parse(inputTokens[1]);

				case SEARCH:
					SearchParser searchP = new SearchParser();
					return cmdDetails = searchP.parse(inputTokens[1]);

				case DISPLAY:
					return cmdDetails = getDisplayCommand(inputTokens[1]);
	

				default:
					return cmdDetails = new CommandInvalid();
			}
		}
		else if(inputTokens.length==1){
			switch(cmd){
				case REDO:
					return cmdDetails = new CommandRedo();

				case UNDO:
					return cmdDetails = new CommandUndo();

				case HELP:
					return cmdDetails =  new CommandHelp();

				case CLEAR:
					return cmdDetails = new CommandClear();

				default:
					return cmdDetails = new CommandInvalid();
			}
		}
		else{
			return cmdDetails = new CommandInvalid();
		}
	}


	private static int getInputNum(String input) {
		int num =-1;
		try{
			num = Integer.parseInt(input);
			return num;
		}catch(NumberFormatException e){
			num=-1;
			return num;
		}
	}


	private static Command getDisplayCommand(String input) {
		input=input.toLowerCase();
		String returnString="";
		switch(input){
			case "all":
			case "":
				returnString="all";
				break;
			case "float":
			case "undecided":
			case "floating":
				returnString="float";
				break;
			case "deadline":
			case "normal":
			case "norm":
				returnString="deadline";
				break;
			case "session":
			case "event":
				returnString="session";
				break;
			case "repeating":
			case "routine":
			case "recurring":
			case "repeat":
			case "recur":
				returnString="recurring";
				break;
			case "done":
			case "completed":
			case "finished":
				returnString="done";
				break;
			case "upcoming":
			case "coming":
				returnString="upcoming";
				break;
			case "undone":
			case "uncompleted":
			case "unfinished":
			case "pending":
			case "incomplete":
			case "in progress":
				returnString="undone";	
				break;
			case "past":
				returnString ="past";
				break;
			default:
				return new CommandInvalid();
		}
		CommandDisplay cmdDisplay = new CommandDisplay(returnString);
		return cmdDisplay;

	}


	private static String[] getToken(String input) {
		input = input.trim();
		input=input.replaceAll(Regex.REGEX_SPACE," ");
		String[] inputTokens = input.split(" ",2); 
		return inputTokens;
	}


	private static CommandType getCmdType(String string) {
		string = string.toLowerCase();
		switch (string) {
			case "a":
			case "add":
				return CommandType.ADD;
			case "d":
			case "delete":
				return CommandType.DELETE;
			case "u":
			case "undo":
				return CommandType.UNDO;
			case "r":
			case "redo":
				return CommandType.REDO;
			case "m":
			case "mark":
				return CommandType.MARK;
			case "um":
			case "unmark":
				return CommandType.UNMARK;
			case "e":
			case "edit":
				return CommandType.EDIT;
			case "s":
			case "search":
				return CommandType.SEARCH;
			case "h":
			case "help":
				return CommandType.HELP;
			case "c":
			case "clear":
				return CommandType.CLEAR;
			case "set":
				return CommandType.SET;
			case "dis":
			case "display":
				return CommandType.DISPLAY;
			default:
				return CommandType.INVALID;
		}
	}
}
```
###### src\Parser\DateParser.java
``` java
 * parser that obtains the different date Strings then use natty parser to parse
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.lang.time.DateUtils;


public class DateParser {

	static final String START_DATE_KEYWORD = "(" + "((?<=\\s|^)(at?|from?))?" + ")";
	static final String CONNECT_DATE_KEYWORD =  "(to |till |until )";

	static final String ALL_DATE_REGEX = "("+ TitleParser.FIRST_DATE_REGEX +"|"+ TitleParser.SECOND_DATE_REGEX +"|"+ TitleParser.MISC_FIRST_DATE_REGEX +"|"+ TitleParser.MISC_SECOND_DATE_REGEX +"|"+
			TitleParser.FIRST_DAY_REGEX +"|"+ TitleParser.SECOND_DAY_REGEX +"|"+ TitleParser.MISC_NUMBERED_DATE_REGEX +"|"+ TitleParser.NUMBERED_DATE_REGEX +")";
	
	public static Calendar[] getDates(String input) {
		System.out.println("this is input to getDates "+input);
		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> timeList = new ArrayList<String>();


		Pattern pattern = Pattern.compile(ALL_DATE_REGEX);
		Matcher matcher = pattern.matcher(input);	

		while (matcher.find( )) {
			System.out.println("Found DATE value: " + matcher.group() );
			dateList.add(matcher.group());
		} 

		pattern = Pattern.compile(Regex.TIME_REGEX);
		matcher = pattern.matcher(input);	

		while (matcher.find( )) {
			System.out.println("Found TIME value: " + matcher.group() );
			timeList.add(matcher.group());
		} 

		try{
			String startTime="";
			String endTime="";
			if(dateList.size()==2){
				Date[] dates = new Date[2];
				if(timeList.size()==2){
					startTime = timeList.get(0)+" "+dateList.get(0);
					endTime= timeList.get(1) +" "+dateList.get(1);
					dates[0]=NattyDateParser.getDate(startTime);
					dates[1]=NattyDateParser.getDate(endTime);

				}
				else if(timeList.size()==0){
					startTime = dateList.get(0);
					endTime = dateList.get(1);
					dates[0]=NattyDateParser.getDate(startTime);
					dates[1]=NattyDateParser.getDate(endTime);
				}
				else{
					startTime = timeList.get(0)+" "+dateList.get(0);
					endTime= timeList.get(0) +" "+dateList.get(1);
					dates[0]=NattyDateParser.getDate(startTime);
					dates[1]=NattyDateParser.getDate(endTime);

				}
				return convertFromDate(dates); 
			}
			else if(dateList.size()==0){
				if(timeList.size()==2){
					Date[] dates = new Date[2];
					startTime = timeList.get(0);
					endTime= timeList.get(1);
					dates[0]=NattyDateParser.getDate(startTime);
					dates[1]=NattyDateParser.getDate(endTime);
					return convertFromDate(dates); 
				}
				else if(timeList.size()==0){
					return convertFromDate(new Date[0]);
				}
				else{
					Date[] dates = new Date[1];
					startTime = timeList.get(0);
					dates[0]=NattyDateParser.getDate(startTime);
					return convertFromDate(dates); 
				}
			}
			else {
				if(timeList.size()==2){
					Date[] dates = new Date[2];
					startTime = timeList.get(0)+" "+dateList.get(0);
					endTime= timeList.get(1) +" "+dateList.get(0);
					dates[0]=NattyDateParser.getDate(startTime);
					dates[1]=NattyDateParser.getDate(endTime);
					return convertFromDate(dates); 
				}
				else if(timeList.size()==0){
					Date[] dates = new Date[1];
					startTime = dateList.get(0);
					dates[0]=NattyDateParser.getDate(startTime);
					return convertFromDate(dates); 
				}
				else{
					Date[] dates = new Date[1];
					startTime = timeList.get(0)+" "+dateList.get(0);
					dates[0]=NattyDateParser.getDate(startTime);
					return convertFromDate(dates); 
				}
			}
		}catch(NullPointerException e){
			return convertFromDate(new Date[0]);
		}

	}

	public static Calendar[] convertFromDate(Date[] dates) {
		Calendar[] result = new Calendar[dates.length];
		for (int i=0; i<dates.length; i++) {
			Calendar cal;
			Date date = dates[i];
			if (date != null) {
				cal = Calendar.getInstance();
				cal.setTime(DateUtils.truncate(date, Calendar.SECOND));
			} else {
				cal = null;
			}
			result[i] = cal;
			System.out.println(cal);
		}
		return result;
	}



}
```
###### src\Parser\DeleteParser.java
``` java
* Parser for deleting a task
*/

import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandDelete;
import logic.commands.CommandInvalid;


public class DeleteParser extends GeneralParser {
	
	public Command parse(String inputArgs){
		try{
		Command cmdDetails =null;
		int inputNum = getInputNum(inputArgs);
		boolean checkSize = checkInputArgs(inputArgs,1);
		if(inputNum<1||!checkSize){
			return cmdDetails = new CommandInvalid();
		}
		cmdDetails = new CommandDelete(inputNum);
		return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new  CommandInvalid();
		}
		
	}
}
```
###### src\Parser\EditParser.java
``` java
 * Parser for editing a task
 */
import java.util.Date;
import java.util.logging.Level;

import logic.Priority;
import logic.commands.Command;
import logic.commands.CommandEdit;
import logic.commands.CommandInvalid;
import logic.commands.CommandType;
import logic.tasks.Deadline;
import logic.tasks.Task;

public class EditParser extends GeneralParser {

	protected Command parse(String inputArgs){
		try{
			Command cmdDetails=null;
			String[] inputTokens = inputArgs.split(Regex.REGEX_SPACE,2);
			int inputNum = getInputNum(inputTokens[0]);

			Task task = getEditTask(inputTokens[1]);
			if(task ==null){
			
				return new CommandInvalid();
			}
			//String description = getDescription(inputArgs);
			cmdDetails = new CommandEdit(inputNum,task);

			return cmdDetails;
		} catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new  CommandInvalid();
		}

	}

	private Task getEditTask(String inputArgs) {
		String title = getTitle(inputArgs);
		if(title.trim().equals("")){
			title=null;
		}
		Calendar[] date = getDateArray(inputArgs);
		Priority tag = getTag(inputArgs);
		int recurring = getRecurring(inputArgs);
		Task task = createTask(title,date,tag,recurring);
		return task;
	}

}
```
###### src\Parser\GeneralParser.java
``` java
 * parser class with the basic methods
 */
import java.util.regex.Pattern;

import logic.Priority;
import logic.commands.Command;
import logic.tasks.Task;
import logic.tasks.TaskUtil;

public abstract class GeneralParser {

	private static final String REGEX_SPACE = "\\s";
	private static final String PERIOD_DAY_REGEX = "("+" every " +"\\d+"+" day(?:s) "+")";
	private static final String PERIOD_WEEK_REGEX = "("+" every " +"\\d+"+" week(?:s) "+")";
	private static final String PERIOD_MONTH_REGEX = "("+" every " +"\\d+"+" month(?:s) "+")";
	private static final String PERIOD_YEAR_REGEX = "("+" every " +"\\d+"+" year(?:s) "+")";
	private static final String NUM_REGEX = "(\\d+)";
	protected abstract Command parse(String inputArgs);


	protected String getTitle(String input){
		String title = TitleParser.getTitle(input);
		return title;
	}

	protected Calendar[] getDateArray(String input){
		Calendar[] dates = DateParser.getDates(input);
		return dates;
	}

	protected int getInputNum(String inputArgs) {
		int num = InputNumParser.getInputNum(inputArgs);
		return num;
	}

	protected boolean checkInputArgs(String inputArgs, int size){
		String[] inputToken = inputArgs.split(REGEX_SPACE);
		if(inputToken.length<size){
			return false;
		}
		return true;
	}

	protected Task createTask(String title, Calendar[] dates, Priority tag, int recurringPeriod) {
		if (dates.length == 0) {
			return TaskUtil.getInstance(title, null);
		} else if (dates.length == 1) {
			if(recurringPeriod==0){
				return TaskUtil.getInstance(title, dates[0]);
			}
			else{
				return TaskUtil.getInstance(title, dates[0],null,recurringPeriod);
			}
		} else {
			return TaskUtil.getInstance(title, dates[0], dates[1], recurringPeriod);
		}
	}

	/*
	protected Task createTask(String title, Date[] dates, Priority tag, int isRecurring){
		Task task=null;
		System.out.println(dates.length);
		if(isRecurring==1){
			task = createRecurringTask(title,dates,tag,isRecurring);
		}
		else{
			task = createNonRecurringTask(title,dates,tag);
		}
		return task;
	}


	private Task createNonRecurringTask(String title, Date[] dates, Priority tag) {
		Task task = null;
		if(dates.length==1||dates.length==0){
			task = createDeadlineTask(title,dates,tag);
		}
		else if(dates.length==2){
			task = createSessionTask(title,dates,tag);
		}
		return task;
	}


	private Task createRecurringTask(String title, Date[] dates, Priority tag, int isRecurring) {
		RecurringTask task = null;
		if(dates.length==1||dates.length==0){
			task = (RecurringTask) TaskUtil.getInstance(title,dates[0],isRecurring);

		}
		else if(dates.length==2){
			task =(RecurringTask) TaskUtil.getInstance(title,dates[0],dates[1],isRecurring);
		}
		return task;
	}


	private Task createDeadlineTask(String title, Date[] dates, Priority tag) {
		Deadline task;
		if(dates.length==1){
		task = (Deadline) TaskUtil.getInstance(title, dates[0]);
		}
		else{
		task = (Deadline) TaskUtil.getInstance(title, null);	
		}
		task.setPriority(tag);
		return task;
	}


	private Task createSessionTask(String title, Date[] dates, Priority tag) {
		Session task = (Session) TaskUtil.getInstance(title,dates[0],dates[1]);

		return task;
	}
	 */
	protected static Priority getTag(String inputArgs) {

		return Priority.NULL;
	}
	protected static int getRecurring(String inputArgs){
		inputArgs = inputArgs.toLowerCase();

		int num = getCustomPeriod(inputArgs);

		if(num!=0){
			return num;
		}

		if(inputArgs.contains("every day")){
			return 1;
		}
		else if(inputArgs.contains("every week")){
			return 7;
		}
		else if(inputArgs.contains("every month")){
			return -1;
		}
		else if(inputArgs.contains("every year")){
			return -2;
		}
		else{
			return 0;
		}

	}


	private static int getCustomPeriod(String inputArgs) {

		int num = 0;

		num = getCustomDays(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomWeeks(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomMonths(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomYears(inputArgs);
		if(num!=0){
			return num;
		}
		return num;
	}


	private static int getCustomYears(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(PERIOD_YEAR_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=-2*num;
		}

		return num;
	}


	private static int getCustomMonths(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(PERIOD_MONTH_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=(1-2*num);
		}
		return num;
	}


	private static int getCustomWeeks(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(PERIOD_WEEK_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=num*7;
		}
		return num;
	}


	private static int getCustomDays(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(PERIOD_DAY_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
		}
		return num;
	}


	private static int getPeriod(String inputArgs) {
		Pattern pattern = Pattern.compile(NUM_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
		}
		int num = Integer.parseInt(matcher.group());
		return num;
	}

}
```
###### src\Parser\InputNumParser.java
``` java
* Parser for getting an input number
*/
public class InputNumParser {
	
	private static final String REGEX_SPACE = "\\s";
	
	public static int getInputNum(String inputArgs) {
		String[] inputTokens = inputArgs.split(REGEX_SPACE);
		String inputNum=inputTokens[0];
		int num;
		try{
			num=Integer.parseInt(inputNum);
		}
		catch(Exception e){
			num=0;
		}
		if(num<1){
			num=0;
		}
		return num;
	}
}
```
###### src\Parser\NattyDateParser.java
``` java
* Parser for using natty to get Date
*/
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class NattyDateParser {

	public static Date getDate(String input) {
		Date date = null;
		Parser parser = new Parser();
		List<DateGroup> dateGroup= parser.parse(input);
		if (dateGroup.isEmpty()) { 
			System.out.println(date);
			return null; 
		}
		List<Date> dates = dateGroup.get(0).getDates();
		date = dates.get(0);
		System.out.println(date);
		return date;
	}

}
```
###### src\Parser\Regex.java
``` java
* class  that contains the general Regex
*/
public class Regex {
static final String REGEX_SPACE = "(\\s+)";
static final String START = "(?<=^|\\s)";
static final String END = "(?=\\s|$)";
static final String MISC_REGEX ="(at?|from?|to?|till? |until?|by?|at?|on?|next?|this?|by next?|by this?)"+REGEX_SPACE;
static final String MONTHNAME = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)";
static final String DATES = "(\\d?\\d)(?:st|rd|nd|th)?";
static final String YEAR = "(\\d{2}|\\d{4})?";

static final String DATE_MONTH_REGEX = "(?<=\\s|^)" + DATES + REGEX_SPACE + MONTHNAME + END;
static final String MONTH_DATE_REGEX = "(?<=\\s|^)" + MONTHNAME +REGEX_SPACE + DATES + END;
static final String DATE_MONTH_YEAR_REGEX = "(?<=\\s|^)" + DATES + REGEX_SPACE+ MONTHNAME + REGEX_SPACE + YEAR + END;
static final String MONTH_DATE_YEAR_REGEX = "(?<=\\s|^)" + MONTHNAME +REGEX_SPACE + DATES + REGEX_SPACE + YEAR + END;

static final String TMR_REGEX = "(today?|tmr?|tomorrow?)";

static final String DAYNAME = "(next week?|next month?|mon(?:day)?|tue(?:sday)?|wed(?:nesday)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)";
static final String TWELVE_HR_REGEX = "([0-9]?[0-9])([.:][0-9][0-9])?\\s?(am|pm)";
static final String TWENTYFOUR_HR_REGEX = "(([0-9]?[0-9])[:]([0-9][0-9]))\\s?[?:h|H]?";

static final String TIME_REGEX = "(" + Regex.TWELVE_HR_REGEX + "|" + Regex.TWENTYFOUR_HR_REGEX + ")";


static final String DAY = "(\\d?\\d)";
static final String MONTH = "(\\d?\\d)";
static final String DATE_SEP = "[-/]";


}
```
###### src\Parser\SearchParser.java
``` java
* Parser for search command
*/
import java.util.Date;
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSearch;
import logic.commands.CommandType;
import logic.tasks.Deadline;

public class SearchParser extends GeneralParser {
	
	protected Command parse(String inputArgs){
		try{
		Command cmdDetails =null;
		String searchKey = getTitle(inputArgs);
		
		if(searchKey.equals("")||searchKey==null){
			return cmdDetails = new CommandInvalid();
		}
		//String description = getDescription(inputTokens[1]);
		cmdDetails = new CommandSearch(searchKey);
		
		return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}
		
	}
}
```
###### src\Parser\SetParser.java
``` java
* Parser for setting storage directory
*/
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSetLocation;
import logic.commands.CommandType;

public class SetParser extends GeneralParser{

	public Command parse(String inputArgs) {
		try{
			CommandType cmd = CommandType.SEARCH;
			Command cmdDetails =null;
			String stringPath = getTitle(inputArgs);
			if(stringPath.equals("")||stringPath==null){
				return cmdDetails = new CommandInvalid();
			}
			//String description = getDescription(inputTokens[1]);
			cmdDetails = new CommandSetLocation(stringPath);

			return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}

	}
}
```
###### src\Parser\TitleParser.java
``` java
* parser that obtains the title
*/
public class TitleParser {
	static final String NO_YEAR_FORMATTED_DATE_REGEX = Regex.START + Regex.DAY + "[-/]" + Regex.MONTH + Regex.END;
	static final String FORMATTED_DATE_WITH_YEAR_REGEX = Regex.START + Regex.DAY + Regex.DATE_SEP + Regex.MONTH + Regex.DATE_SEP + Regex.YEAR + Regex.END;
	static final String NUMBERED_DATE_REGEX = NO_YEAR_FORMATTED_DATE_REGEX + "|" + FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String MISC_NUMBERED_DATE_REGEX = Regex.MISC_REGEX+NO_YEAR_FORMATTED_DATE_REGEX + "|" + Regex.MISC_REGEX+FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String FIRST_DATE_REGEX = Regex.DATE_MONTH_YEAR_REGEX+ "|" + Regex.MONTH_DATE_YEAR_REGEX+"|"+Regex.MONTH_DATE_REGEX+"|"+Regex.DATE_MONTH_REGEX;
	static final String MISC_FIRST_DATE_REGEX =  Regex.DATE_MONTH_YEAR_REGEX+ "|" + Regex.MONTH_DATE_YEAR_REGEX;
	static final String SECOND_DATE_REGEX=Regex.MISC_REGEX+ Regex.DATE_MONTH_REGEX+ "|" + Regex.MISC_REGEX+Regex.MONTH_DATE_REGEX;
	static final String MISC_SECOND_DATE_REGEX = Regex.MISC_REGEX+ Regex.DATE_MONTH_YEAR_REGEX+ "|" +Regex.MISC_REGEX+ Regex.MONTH_DATE_YEAR_REGEX;
	static final String FIRST_DAY_REGEX=Regex.START+Regex.MISC_REGEX+Regex.TMR_REGEX+ Regex.END +"|"+Regex.START+Regex.TMR_REGEX+ Regex.END ;
	
	static final String MISC_TIME_REGEX = Regex.MISC_REGEX + Regex.TWELVE_HR_REGEX + "|" + Regex.MISC_REGEX+ Regex.TWENTYFOUR_HR_REGEX;
	static final String SECOND_DAY_REGEX=Regex.MISC_REGEX + Regex.DAYNAME+Regex.END+"|"+Regex.DAYNAME+ Regex.END;

	static final String NOT_TITLE_REGEX = "("+ FIRST_DATE_REGEX +"|"+ SECOND_DATE_REGEX +"|"+ MISC_FIRST_DATE_REGEX +"|"+ MISC_SECOND_DATE_REGEX +"|"+
			FIRST_DAY_REGEX +"|"+ SECOND_DAY_REGEX +"|"+ MISC_NUMBERED_DATE_REGEX +"|"+ NUMBERED_DATE_REGEX +"|"+ Regex.TIME_REGEX+"|"+MISC_TIME_REGEX +"|"+Regex.TMR_REGEX+")";
	
	public static String getTitle(String inputArgs) {
		
		if (inputArgs == null) {
			return null;
		}
		String[] strTok = inputArgs.split(NOT_TITLE_REGEX,2);
		System.out.println("title parsed = "+strTok[0]);
		return strTok[0].trim();

	}















}
```
