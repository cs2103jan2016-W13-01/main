# A0121535R
###### src\logic\commands\CommandHelp.java
``` java
 * This class contains details for help commands
 */
public class CommandHelp implements Command{
	
	private static final String TOPIC_SEPARATOR = "--------------------------------------\r\n";
	private static final String MESSAGE_HELP = "Welcome to help topics!";
	private static final String MESSAGE_HELP_TOPIC = "Welcome to help topic for: %s!";
	private static final String HELP_FILE_NAME = "./src/document/help.txt";
	private static final String MESSAGE_NO_HELP_CONTENT = "Sorry, the help contents will be included in our next version!";
	private static final String MESSAGE_NO_HELP_TOPIC = "Sorry, there are no help contents for this topic.";
	
	private String topic;

	public CommandType getType() {
		return CommandType.HELP;
	}
	
	public CommandHelp() {
		topic = null;
	}
	
	public CommandHelp(String topicName) {
		topic = topicName;
	}
	
	public ArrayList<String> getHelpContent() {
		if (topic != null) {
			return getHelpTopic(topic);
		} else {
			return getHelpTopics();
		}
	}
	
	public ArrayList<String> getHelpTopics() {
		ArrayList<String> result = new ArrayList<String>();
		try {
			Scanner sc = new Scanner(new File(HELP_FILE_NAME));
			while (sc.hasNextLine()) {
			    appendHelpTopic(result, sc);
			}
			return result;
		} catch (IOException e) {
			e.printStackTrace();
			result.add(MESSAGE_NO_HELP_CONTENT);
			return result;
		}
	}

	private void appendHelpTopic(ArrayList<String> list, Scanner sc) {
		String line = sc.nextLine();
		if (line.trim().equals("{")) {
			StringBuilder sb = new StringBuilder();
			line = sc.nextLine();
			while (!line.trim().equals("}")) {
				sb.append(line);
				sb.append("\r\n");
				line = sc.nextLine();
			}
			sb.append(TOPIC_SEPARATOR);
			list.add(sb.toString());
		}
	}
	
	public ArrayList<String> getHelpTopic(String topicName) {
		ArrayList<String> result = new ArrayList<String>();
		try {
			Scanner sc = new Scanner(new File(HELP_FILE_NAME));
			boolean found = false;
			while (sc.hasNextLine()) {
				found = foundAndAppend(topicName, result, sc, found);
			}
			if (found) {
				return result;
			} else {
				result.add(MESSAGE_NO_HELP_TOPIC);
				return result;
			}
		} catch (IOException e) {
			e.printStackTrace();
			result.add(MESSAGE_NO_HELP_CONTENT);
			return result;
		}
	}

	private boolean foundAndAppend(String topicName, ArrayList<String> list,
										Scanner sc, boolean found)
	{
		String open = sc.nextLine();
		if (open.trim().equals("{")) {
			String line = sc.nextLine();
			found = line.split(":")[1].trim().equals(topicName);
			if (found) {
				StringBuilder sb = new StringBuilder();
				found = true;
				while (!line.trim().equals("}")) {
					sb.append(line);
					sb.append("\r\n");
					line = sc.nextLine();
				}
				sb.append(TOPIC_SEPARATOR);
				list.add(sb.toString());
			}
		}
		return found;
	}
	
	public String execute() {
		if (topic != null) {
			return String.format(MESSAGE_HELP_TOPIC, topic);
		}
		return MESSAGE_HELP;
	}
	
	public String undo() {
		return null;
	}

}
```
###### src\Parser\AddParser.java
``` java
//Parser that calls the required methods for adding a task
import java.util.Calendar;
import java.util.logging.Level;
import logic.Priority;
import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandInvalid;
import logic.tasks.Task;

public class AddParser extends GeneralParser {

	public Command parse(String inputArgs){
		try{
			String notTitleToken = inputArgs;
			int[] startEndArray = new int[2];
			String title;
			boolean check = checkAbsoluteTitle(inputArgs,startEndArray);
			if(check == true){
				title=inputArgs.substring(startEndArray[0]+1,startEndArray[1]);
				notTitleToken = inputArgs.substring(startEndArray[1]+1);
			} else{
				title = getTitle(inputArgs);
			}
			Calendar[] date = getDateArray(notTitleToken);
			Priority tag = getTag(inputArgs);
			int recurring = getRecurring(notTitleToken);
			System.out.println("add reccur "+recurring);
			Task task = createTask(title,date,tag,recurring);
			Command cmdDetails = new CommandAdd(task);
			return cmdDetails;

		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "add processing error", e);
			return new CommandInvalid();
		}
	}
	
	//check if there is "<title>"
	private static boolean checkAbsoluteTitle(String inputArgs, int[] array) {
		int absIndexStart = inputArgs.indexOf("\""); 
		if(absIndexStart>=0){
			int absIndexEnd = inputArgs.indexOf("\"",absIndexStart+1);
			if(absIndexEnd >absIndexStart && absIndexEnd>=0){
				array[0]=absIndexStart;
				array[1]=absIndexEnd;
				return true;
			}
		}
		return false;
	}

}
```
###### src\Parser\CommandParser.java
``` java
//inital parser called by logic, that sort the input to the respective parser classes

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import logic.commands.Command;
import logic.commands.CommandClear;
import logic.commands.CommandDisplay;
import logic.commands.CommandGetLocation;
import logic.commands.CommandHelp;
import logic.commands.CommandInvalid;
import logic.commands.CommandMark;
import logic.commands.CommandRedo;
import logic.commands.CommandType;
import logic.commands.CommandUndo;
import logic.commands.CommandUnmark;

public class CommandParser {

	public static Logger parserLogger = Logger.getLogger(CommandParser.class.getName());
	public static SimpleDateFormat sdf;
	public static CommandParser cmdParser;
	static FileHandler fh; 
	private static HashMap<String, String> hashmap;

	private static final String DISPLAY_ALL ="all";
	private static final String DISPLAY_FLOAT ="float";
	private static final String DISPLAY_DEADLINE="deadline";
	private static final String DISPLAY_SESSION="session";
	private static final String DISPLAY_RECURRING="recurring";
	private static final String DISPLAY_DONE="done";
	private static final String DISPLAY_UPCOMING="upcoming";
	private static final String DISPLAY_UNDONE="undone";
	private static final String DISPLAY_PAST="past";
	private static final String DISPLAY_HELP="help";

	public CommandParser() throws SecurityException, IOException {
		sdf = new SimpleDateFormat("ddMMyyyy HHmm");
		sdf.setLenient(false);
		FileHandler fh = new FileHandler("./log/MyLogFile.txt");  
		parserLogger.addHandler(fh);
		System.out.println("where is my log file "+getClass().getClassLoader().getResource("logging.properties"));
		parserLogger.log(Level.INFO, "log starting");

	}

	public static CommandParser getInstance() throws SecurityException, IOException{
		if (cmdParser == null){
			cmdParser= new CommandParser();
			cmdParser.init();
		}
		return cmdParser;
	}

	private void init() {
		hashmap = new HashMap<String, String>(); 
		hashAddAll();
		hashAddFloat();
		hashAddDeadline();
		hashAddSession();
		hashAddRecurring();
		hashAddDone();
		hashAddUndone();
		hashAddUpcoming();
		hashAddPast();
		hashAddHelp();
	}

	private void hashAddHelp() {
		CommandParser.hashmap.put(DISPLAY_HELP, DISPLAY_HELP);
		CommandParser.hashmap.put("halp",DISPLAY_HELP);
	}


	private void hashAddPast() {
		CommandParser.hashmap.put(DISPLAY_PAST, DISPLAY_PAST);
	}


	private void hashAddUpcoming() {
		CommandParser.hashmap.put(DISPLAY_UPCOMING, DISPLAY_UPCOMING);
		CommandParser.hashmap.put("coming", DISPLAY_UPCOMING);

	}


	private void hashAddUndone() {
		CommandParser.hashmap.put(DISPLAY_UNDONE, DISPLAY_UNDONE);
		CommandParser.hashmap.put("uncompleted", DISPLAY_UNDONE);
		CommandParser.hashmap.put("unfinished", DISPLAY_UNDONE);
		CommandParser.hashmap.put("pending", DISPLAY_UNDONE);
		CommandParser.hashmap.put("incomplete", DISPLAY_UNDONE);
		CommandParser.hashmap.put("in progress", DISPLAY_UNDONE);
		CommandParser.hashmap.put("uncomplete", DISPLAY_UNDONE);
		CommandParser.hashmap.put("incompleted", DISPLAY_UNDONE);
	}


	private void hashAddDone() {
		CommandParser.hashmap.put(DISPLAY_DONE, DISPLAY_DONE);
		CommandParser.hashmap.put("completed", DISPLAY_DONE);
		CommandParser.hashmap.put("finished", DISPLAY_DONE);
		CommandParser.hashmap.put("complete", DISPLAY_DONE);
	}


	private void hashAddRecurring() {
		CommandParser.hashmap.put("repeating", DISPLAY_RECURRING);
		CommandParser.hashmap.put("routine", DISPLAY_RECURRING);
		CommandParser.hashmap.put(DISPLAY_RECURRING, DISPLAY_RECURRING);
		CommandParser.hashmap.put("repeat", DISPLAY_RECURRING);
		CommandParser.hashmap.put("recur", DISPLAY_RECURRING);
	}


	private void hashAddSession() {
		CommandParser.hashmap.put(DISPLAY_SESSION, DISPLAY_SESSION);
		CommandParser.hashmap.put("event",  DISPLAY_SESSION);
	}


	private void hashAddDeadline() {
		CommandParser.hashmap.put(DISPLAY_DEADLINE,DISPLAY_DEADLINE);
		CommandParser.hashmap.put("normal", DISPLAY_DEADLINE);
		CommandParser.hashmap.put("norm", DISPLAY_DEADLINE);
	}


	private void hashAddFloat() {
		CommandParser.hashmap.put(DISPLAY_FLOAT, DISPLAY_FLOAT);
		CommandParser.hashmap.put("undecided",DISPLAY_FLOAT );
		CommandParser.hashmap.put("floating", DISPLAY_FLOAT);
	}


	private void hashAddAll() {
		CommandParser.hashmap.put("", DISPLAY_ALL);
		CommandParser.hashmap.put(DISPLAY_ALL,DISPLAY_ALL);
	}

	//sort the keyword at the start by the commandtypes to the different type of classes
	public static Command parseInput(String input) {
		try{
			if (cmdParser == null){
				cmdParser= new CommandParser();
				cmdParser.init();
			}
		} catch( SecurityException e){
			e.printStackTrace();
		} catch (IOException e){
			e.printStackTrace();
		}
		String[] inputTokens = getToken(input);
		CommandType cmd = getCmdType(inputTokens[0]);
		if(inputTokens.length==2){
			switch(cmd){
				case ADD:
					AddParser ap = new AddParser();
					return ap.parse(inputTokens[1]);

				case DELETE:
					DeleteParser dp = new DeleteParser();
					return dp.parse(inputTokens[1]);

				case EDIT:
					EditParser ep = new EditParser();
					return ep.parse(inputTokens[1]);

				case MARK:
					int inputNum = getInputNum(inputTokens[1]);
					if(inputNum==-1){
						cmd=CommandType.INVALID;
					}
					return new CommandMark(inputNum);

				case UNMARK:
					inputNum = getInputNum(inputTokens[1]);
					if(inputNum==-1){
						cmd=CommandType.INVALID;
					}
					return new CommandUnmark(inputNum);

				case SET:
					SetParser setParser = new SetParser();
					return setParser.parse(inputTokens[1]);

				case SEARCH:
					SearchParser searchP = new SearchParser();
					return searchP.parse(inputTokens[1]);

				case DISPLAY:
					return getDisplayCommand(inputTokens[1]);

				default:
					return new CommandInvalid();
			}
		} else if(inputTokens.length==1){
			switch(cmd){
				case REDO:
					return new CommandRedo();

				case UNDO:
					return new CommandUndo();

				case HELP:
					return new CommandHelp();

				case CLEAR:
					return new CommandClear();
				case GET:
					return new CommandGetLocation();

				default:
					return new CommandInvalid();
			}
		} else{
			return new CommandInvalid();
		}
	}


	private static int getInputNum(String input) {
		int num =-1;
		try{
			num = Integer.parseInt(input);
			return num;
		} catch(NumberFormatException e){
			num=-1;
			return num;
		}
	}


	private static Command getDisplayCommand(String input) {
		input=input.toLowerCase();
		input=input.trim();
		System.out.println("input at cmdParser is "+input);
		String returnString;

		try{
			returnString = CommandParser.hashmap.get(input);
		} catch(NullPointerException e){
			System.out.println("returnstring is null");
			returnString=null;
		}

		if(returnString==DISPLAY_HELP){
			return new CommandHelp();
		} else if(returnString==null){
			return new CommandInvalid();
		} else{
			CommandDisplay cmdDisplay = new CommandDisplay(returnString);
			return cmdDisplay;
		}
	}


	private static String[] getToken(String input) {
		input = input.trim();
		input=input.replaceAll(Regex.REGEX_SPACE," ");
		String[] inputTokens = input.split(" ",2); 
		return inputTokens;
	}


	private static CommandType getCmdType(String string) {
		string = string.toLowerCase();
		switch (string) {
			case "a":
			case "add":
			case "create":
				return CommandType.ADD;
			case "d":
			case "delete":
			case "remove":
				return CommandType.DELETE;
			case "u":
			case "undo":
				return CommandType.UNDO;
			case "r":
			case "redo":
				return CommandType.REDO;
			case "m":
			case "mark":
			case "complete":
			case "finished":
				return CommandType.MARK;
			case "um":
			case "unmark":
				return CommandType.UNMARK;
			case "e":
			case "edit":
				return CommandType.EDIT;
			case "s":
			case "search":
				return CommandType.SEARCH;
			case "h":
			case "help":
				return CommandType.HELP;
			case "c":
			case "clear":
			case "kill":
				return CommandType.CLEAR;
			case "set":
			case "save":
				return CommandType.SET;
			case "get":
			case "dir":
			case "cd":
				return CommandType.GET;
			case "dis":
			case "display":
				return CommandType.DISPLAY;
			default:
				return CommandType.INVALID;
		}
	}
}
```
###### src\Parser\DateParser.java
``` java
// parser that obtains the different date Strings then use natty parser to parse
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang.time.DateUtils;

public class DateParser {

	static final String START_DATE_KEYWORD = "(" + "((?<=\\s|^)(at?|from?))?" + ")";
	static final String CONNECT_DATE_KEYWORD =  "(to |till |until )";

	static final String ALL_DATE_REGEX = "("+ TitleParser.FIRST_DATE_REGEX +"|"+ TitleParser.SECOND_DATE_REGEX +"|"+ TitleParser.MISC_FIRST_DATE_REGEX +"|"+ TitleParser.MISC_SECOND_DATE_REGEX +"|"+
			TitleParser.FIRST_DAY_REGEX +"|"+ TitleParser.SECOND_DAY_REGEX +"|"+ TitleParser.MISC_NUMBERED_DATE_REGEX +"|"+ TitleParser.NUMBERED_DATE_REGEX +")";
	
	//initial method called by other parser classes
	public static Calendar[] getDates(String input) {
		System.out.println("this is input to getDates "+input);
		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> timeList = new ArrayList<String>();
		Calendar[] cal =  getCalendar(input, dateList, timeList);
		return cal;
	}
	
	//obtain the part of the string that has to do with dates
	//obtain the part of the string that has to do with times
	private static Calendar[] getCalendar(String input, ArrayList<String> dateList, ArrayList<String> timeList) {
		Pattern pattern = Pattern.compile(ALL_DATE_REGEX);
		Matcher matcher = pattern.matcher(input);	
		getDays(dateList, matcher); 
		pattern = Pattern.compile(Regex.TIME_REGEX);
		matcher = pattern.matcher(input);	
		getTimes(timeList, matcher); 
		Calendar[] cal = sortByDateSize(dateList, timeList);
		return cal;
	}
	
	//sort by the number of dates input
	//e.g 15 may and/or 03/03/2013
	private static Calendar[] sortByDateSize(ArrayList<String> dateList, ArrayList<String> timeList) {
		try{
			if(dateList.size()==2){
				Date[] dates = dateSizeTwo(dateList, timeList);
				return convertFromDate(dates); 
			} else if(dateList.size()==0){
				Calendar[] cal = dateSizeZero(timeList);
				return cal;
			} else {
				return dateSizeOne(dateList, timeList);
			}
		} catch(NullPointerException e){
			return convertFromDate(new Date[0]);
		}
	}
	
	//if input date is only one
	private static Calendar[] dateSizeOne(ArrayList<String> dateList, ArrayList<String> timeList) {
		String startTime;
		String endTime;
		if(timeList.size()==2){
			Date[] dates = new Date[2];
			startTime = timeList.get(0)+" "+dateList.get(0);
			endTime= timeList.get(1) +" "+dateList.get(0);
			obtainDatesArray(startTime, endTime, dates);
			return convertFromDate(dates); 
		} else if(timeList.size()==0){
			Date[] dates = new Date[1];
			startTime = dateList.get(0);
			dates[0]=NattyDateParser.getDate(startTime);
			return convertFromDate(dates); 
		} else{
			Date[] dates = new Date[1];
			startTime = timeList.get(0)+" "+dateList.get(0);
			dates[0]=NattyDateParser.getDate(startTime);
			return convertFromDate(dates); 
		}
	}
	
	//if no input date
	private static Calendar[] dateSizeZero(ArrayList<String> timeList) {
		String startTime;
		String endTime;
		if(timeList.size()==2){
			Date[] dates = new Date[2];
			startTime = timeList.get(0);
			endTime= timeList.get(1);
			obtainDatesArray(startTime, endTime, dates);
			return convertFromDate(dates); 
		} else if(timeList.size()==0){
			return convertFromDate(new Date[0]);
		} else{
			Date[] dates = new Date[1];
			startTime = timeList.get(0);
			dates[0]=NattyDateParser.getDate(startTime);
			return convertFromDate(dates); 
		}
	}
	
	//if input date is two
	private static Date[] dateSizeTwo(ArrayList<String> dateList, ArrayList<String> timeList) {
		String startTime;
		String endTime;
		Date[] dates = new Date[2];
		if(timeList.size()==2){		
			startTime = obtainFullDateString(timeList.get(0),dateList.get(0));
			endTime = obtainFullDateString(timeList.get(1),dateList.get(1));
			obtainDatesArray(startTime, endTime, dates);
		} else if(timeList.size()==0){
			startTime = dateList.get(0);
			endTime = dateList.get(1);
			obtainDatesArray(startTime, endTime, dates);
		} else{
			startTime = obtainFullDateString(timeList.get(0),dateList.get(0));
			endTime = obtainFullDateString(timeList.get(0),dateList.get(1));
			obtainDatesArray(startTime, endTime, dates);
		}
		return dates;
	}
	
	//concat the time and date together
	private static String obtainFullDateString (String time , String date){
		String string = time+" "+date;
		return string;
	}
	
	private static void obtainDatesArray(String startTime, String endTime, Date[] dates) {
		dates[0]=NattyDateParser.getDate(startTime);
		dates[1]=NattyDateParser.getDate(endTime);
	}

	private static void getTimes(ArrayList<String> timeList, Matcher matcher) {
		while (matcher.find( )) {
			System.out.println("Found TIME value: " + matcher.group() );
			timeList.add(matcher.group());
		}
	}

	private static void getDays(ArrayList<String> dateList, Matcher matcher) {
		while (matcher.find( )) {
			System.out.println("Found DATE value: " + matcher.group() );
			dateList.add(matcher.group());
		}
	}

	public static Calendar[] convertFromDate(Date[] dates) {
		Calendar[] result = new Calendar[dates.length];
		for (int i=0; i<dates.length; i++) {
			Calendar cal;
			Date date = dates[i];
			if (date != null) {
				cal = Calendar.getInstance();
				cal.setTime(DateUtils.truncate(date, Calendar.SECOND));
			} else {
				cal = null;
			}
			result[i] = cal;
			System.out.println(cal);
		}
		return result;
	}



}
```
###### src\Parser\DeleteParser.java
``` java
//Parser for deleting a task

import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandDelete;
import logic.commands.CommandInvalid;


public class DeleteParser extends GeneralParser {

	public Command parse(String inputArgs){
		try{
			Command cmdDetails =null;
			int inputNum = getInputNum(inputArgs);
			boolean checkSize = checkInputArgs(inputArgs,1);
			if(inputNum<1||!checkSize){
				return cmdDetails = new CommandInvalid();
			}
			cmdDetails = new CommandDelete(inputNum);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new  CommandInvalid();
		}	
	}
}
```
###### src\Parser\EditParser.java
``` java
//Parser for editing a task

import java.util.Calendar;
import java.util.logging.Level;
import logic.Priority;
import logic.commands.Command;
import logic.commands.CommandEdit;
import logic.commands.CommandInvalid;
import logic.tasks.Task;

public class EditParser extends GeneralParser {

	protected Command parse(String inputArgs){
		try{
			Command cmdDetails=null;
			String[] inputTokens = inputArgs.split(Regex.REGEX_SPACE,2);
			int inputNum = getInputNum(inputTokens[0]);

			Task task = getEditTask(inputTokens[1]);
			if(task ==null){
				return new CommandInvalid();
			}
			cmdDetails = new CommandEdit(inputNum,task);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new  CommandInvalid();
		}
	}

	private Task getEditTask(String inputArgs) {
		String notTitleToken = inputArgs;
		int[] startEndArray = new int[2];
		String title=null;
		boolean check = checkAbsoluteTitle(inputArgs,startEndArray);
		if(check == true){
			title=inputArgs.substring(startEndArray[0]+1,startEndArray[1]);
			notTitleToken = inputArgs.substring(startEndArray[1]+1);
			System.out.println("this is true");
		}
		Calendar[] date = getDateArray(notTitleToken);
		Priority tag = getTag(inputArgs);
		int recurring = getRecurring(inputArgs);
		Task task = createTask(title,date,tag,recurring);
		return task;
	}
	
	//check if there is "<title>"
	private static boolean checkAbsoluteTitle(String inputArgs, int[] array) {
		int absIndexStart = inputArgs.indexOf("\""); 
		if(absIndexStart>=0){
			int absIndexEnd = inputArgs.indexOf("\"",absIndexStart+1);
			if(absIndexEnd >absIndexStart && absIndexEnd>=0){
				array[0]=absIndexStart;
				array[1]=absIndexEnd;
				return true;
			}
		}
		return false;
	}

}
```
###### src\Parser\GeneralParser.java
``` java
//parser class with the general methods

import java.util.Calendar;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import logic.Priority;
import logic.commands.Command;
import logic.tasks.Task;
import logic.tasks.TaskUtil;

public abstract class GeneralParser {


	protected abstract Command parse(String inputArgs);


	protected String getTitle(String input){
		String title = TitleParser.getParsedTitle(input);
		return title;
	}

	protected Calendar[] getDateArray(String input){
		Calendar[] dates = DateParser.getDates(input);
		return dates;
	}

	protected int getInputNum(String inputArgs) {
		int num = InputNumParser.getInputNum(inputArgs);
		return num;
	}

	protected boolean checkInputArgs(String inputArgs, int size){
		String[] inputToken = inputArgs.split(Regex.REGEX_SPACE);
		if(inputToken.length<size){
			return false;
		}
		return true;
	}

	protected Task createTask(String title, Calendar[] dates, Priority tag, int recurringPeriod) {
		System.out.println("Recurring! "+recurringPeriod);
		if (dates.length == 0) {
			if(title==null){
				System.out.println("Recurring only ! "+recurringPeriod);
				return TaskUtil.getInstance(title, null,null,recurringPeriod);
			}
			return TaskUtil.getInstance(title, null);
		} else if (dates.length == 1) {
			if(recurringPeriod==0){
				return TaskUtil.getInstance(title, dates[0]);
			} else{
				return TaskUtil.getInstance(title, dates[0],null,recurringPeriod);
			}
		} else {
			return TaskUtil.getInstance(title, dates[0], dates[1], recurringPeriod);
		}
	}


	protected static Priority getTag(String inputArgs) {
		return Priority.NULL;
	}
	
	//obtain the int values that represents the recurring dates
	protected static int getRecurring(String inputArgs){
		inputArgs = inputArgs.toLowerCase();

		if(inputArgs.contains("every day")){
			return 1;
		} else if(inputArgs.contains("every week")){
			return 7;
		} else if(inputArgs.contains("every month")){
			return -1;
		} else if(inputArgs.contains("every year")){
			return -2;
		} else{
			int num = getCustomPeriod(inputArgs);
			return num;
		}

	}


	private static int getCustomPeriod(String inputArgs) {

		int num = 0;

		num = getCustomDays(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomWeeks(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomMonths(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomYears(inputArgs);
		if(num!=0){
			return num;
		}
		return num;
	}


	private static int getCustomYears(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_YEAR_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=-2*num;
		}
		return num;
	}


	private static int getCustomMonths(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_MONTH_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=(1-2*num);
		}
		return num;
	}


	private static int getCustomWeeks(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_WEEK_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=num*7;
		}
		return num;
	}


	private static int getCustomDays(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_DAY_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
		}
		return num;
	}


	private static int getPeriod(String inputArgs) {
		Pattern pattern = Pattern.compile(Regex.NUM_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
		}
		int num = Integer.parseInt(matcher.group());
		return num;
	}

}
```
###### src\Parser\InputNumParser.java
``` java
//class for getting an input number

public class InputNumParser {

	private static final String REGEX_SPACE = "\\s";

	public static int getInputNum(String inputArgs) {
		String[] inputTokens = inputArgs.split(REGEX_SPACE);
		String inputNum=inputTokens[0];
		int num;
		try{
			num=Integer.parseInt(inputNum);
		} catch(NumberFormatException e){
			num=0;
		}
		if(num<1){
			num=0;
		}
		return num;
	}
}
```
###### src\Parser\NattyDateParser.java
``` java
// Parser for using external library natty to get Date

import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class NattyDateParser {

	public static Date getDate(String input) {
		Date date = null;
		Parser parser = new Parser();
		List<DateGroup> dateGroup= parser.parse(input);
		if (dateGroup.isEmpty()) { 
			System.out.println(date);
			return null; 
		}
		List<Date> dates = dateGroup.get(0).getDates();
		date = dates.get(0);
		System.out.println(date);
		return date;
	}

}
```
###### src\Parser\Regex.java
``` java
// class  that contains the general Regex

public class Regex {
	static final String REGEX_SPACE = "(\\s+)";
	static final String START = "(?<=^|\\s)";
	static final String END = "(?=\\s|$)";
	static final String MISC_REGEX =START+"(from?|to?|till?|until?|by?|on?|next?|this?|by next?|by this?)?";
	static final String MONTHNAME = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)";
	static final String DATES = "(\\d?\\d)(?:st|rd|nd|th)?";
	static final String YEAR = "(\\d{2}|\\d{4})?";
	static final String DATE_MONTH_REGEX = "(?<=\\s|^)" + DATES + REGEX_SPACE + MONTHNAME + END;
	static final String MONTH_DATE_REGEX = "(?<=\\s|^)" + MONTHNAME +REGEX_SPACE + DATES + END;
	static final String DATE_MONTH_YEAR_REGEX = "(?<=\\s|^)" + DATES + REGEX_SPACE+ MONTHNAME + REGEX_SPACE + YEAR + END;
	static final String MONTH_DATE_YEAR_REGEX = "(?<=\\s|^)" + MONTHNAME +REGEX_SPACE + DATES + REGEX_SPACE + YEAR + END;
	static final String TMR_REGEX = "(today?|tmr?|tomorrow?)";
	static final String DAYNAME = "(next week?|next month?|mon(?:day)?|tue(?:sday)?|wed(?:nesday)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)";
	static final String TWELVE_HR_REGEX = "([0-9]?[0-9])([.:][0-9][0-9])?\\s?(am|pm)";
	static final String TWENTYFOUR_HR_REGEX = "(([0-9]?[0-9])[:]([0-9][0-9]))\\s?[?:h|H]?";
	static final String NUM_REGEX= "(\\d+)";
	static final String TIME_REGEX = "(" + Regex.TWELVE_HR_REGEX + "|" + Regex.TWENTYFOUR_HR_REGEX + ")";
	static final String DAY = "(\\d?\\d)";
	static final String MONTH = "(\\d?\\d)";
	static final String DATE_SEP = "[-/]";
	static final String PERIOD_DAY_REGEX = "every"+REGEX_SPACE+"day" + END;
	static final String PERIOD_WEEK_REGEX ="every"+REGEX_SPACE+"week" + END;
	static final String PERIOD_MONTH_REGEX ="every"+REGEX_SPACE+"month" + END;
	static final String PERIOD_YEAR_REGEX ="every"+REGEX_SPACE+"year" + END;
	static final String PERIOD_DAY_REGEX_MUL = "every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(day|days)" + END;
	static final String PERIOD_WEEK_REGEX_MUL ="every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(week|weeks)" + END;
	static final String PERIOD_MONTH_REGEX_MUL ="every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(month|months)" + END;
	static final String PERIOD_YEAR_REGEX_MUL ="every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(year|years)" + END;
	static final String RECURRING_REGEX= START+PERIOD_DAY_REGEX+ "|"+ START+PERIOD_WEEK_REGEX +"|"+START+PERIOD_MONTH_REGEX+"|"+START+PERIOD_YEAR_REGEX;
	static final String RECURRING_REGEX_MUL=START+PERIOD_DAY_REGEX_MUL+ "|" +START+PERIOD_WEEK_REGEX_MUL +"|"+START+PERIOD_MONTH_REGEX_MUL+"|"+START+PERIOD_YEAR_REGEX_MUL;
	static final String RECURRING_REGEX_FINAL = RECURRING_REGEX+"|"+RECURRING_REGEX_MUL;
}
```
###### src\Parser\SearchParser.java
``` java
//Parser for search command

import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSearch;

public class SearchParser extends GeneralParser {

	protected Command parse(String inputArgs){
		try{
			Command cmdDetails =null;
			String searchKey = inputArgs;
			if(searchKey.equals("")||searchKey==null){
				return cmdDetails = new CommandInvalid();
			}
			cmdDetails = new CommandSearch(searchKey);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}

	}
}
```
###### src\Parser\SetParser.java
``` java
//Parser for returning storage directory string

import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSetLocation;

public class SetParser extends GeneralParser{

	public Command parse(String inputArgs) {
		try{
			Command cmdDetails =null;
			String stringPath = inputArgs;
			if(stringPath.equals("")||stringPath==null){
				return cmdDetails = new CommandInvalid();
			}
			cmdDetails = new CommandSetLocation(stringPath);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}

	}
}
```
###### src\Parser\TitleParser.java
``` java
// parses the title

public class TitleParser {
	static final String NO_YEAR_FORMATTED_DATE_REGEX = Regex.START + Regex.DAY + "[-/]" + Regex.MONTH + Regex.END;
	static final String MISC_NO_YEAR_FORMATTED_DATE_REGEX = Regex.START+Regex.MISC_REGEX+Regex.REGEX_SPACE+ Regex.DAY + "[-/]" + Regex.MONTH + Regex.END;
	static final String FORMATTED_DATE_WITH_YEAR_REGEX = Regex.START + Regex.DAY + Regex.DATE_SEP + Regex.MONTH + Regex.DATE_SEP + Regex.YEAR + Regex.END;
	static final String MISC_FORMATTED_DATE_WITH_YEAR_REGEX = Regex.START +Regex.MISC_REGEX+Regex.REGEX_SPACE+ Regex.DAY + Regex.DATE_SEP + Regex.MONTH + Regex.DATE_SEP + Regex.YEAR + Regex.END;
	static final String NUMBERED_DATE_REGEX = NO_YEAR_FORMATTED_DATE_REGEX + "|" + FORMATTED_DATE_WITH_YEAR_REGEX+"|"+MISC_NO_YEAR_FORMATTED_DATE_REGEX+"|"+MISC_FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String MISC_NUMBERED_DATE_REGEX = Regex.MISC_REGEX+NO_YEAR_FORMATTED_DATE_REGEX + "|" + Regex.MISC_REGEX+FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String FIRST_DATE_REGEX = Regex.DATE_MONTH_YEAR_REGEX+ "|" + Regex.MONTH_DATE_YEAR_REGEX+"|"+Regex.MONTH_DATE_REGEX+"|"+Regex.DATE_MONTH_REGEX;
	static final String MISC_FIRST_DATE_REGEX =  Regex.DATE_MONTH_YEAR_REGEX+ "|" + Regex.MONTH_DATE_YEAR_REGEX;
	static final String SECOND_DATE_REGEX=Regex.MISC_REGEX+ Regex.DATE_MONTH_REGEX+ "|" + Regex.MISC_REGEX+Regex.MONTH_DATE_REGEX;
	static final String MISC_SECOND_DATE_REGEX = Regex.MISC_REGEX+ Regex.DATE_MONTH_YEAR_REGEX+ "|" +Regex.MISC_REGEX+ Regex.MONTH_DATE_YEAR_REGEX;
	static final String FIRST_DAY_REGEX=Regex.START+Regex.MISC_REGEX+Regex.REGEX_SPACE+Regex.TMR_REGEX+ Regex.END +"|"+Regex.START+Regex.TMR_REGEX+ Regex.END ;

	static final String MISC_TIME_REGEX = Regex.MISC_REGEX + Regex.TWELVE_HR_REGEX + "|" + Regex.MISC_REGEX+ Regex.TWENTYFOUR_HR_REGEX;
	static final String SECOND_DAY_REGEX=Regex.MISC_REGEX +Regex.REGEX_SPACE+ Regex.DAYNAME+Regex.END+"|"+Regex.DAYNAME+ Regex.END;

	static final String NOT_TITLE_REGEX = "("+ Regex.RECURRING_REGEX_FINAL +"|"+ FIRST_DATE_REGEX +"|"+ SECOND_DATE_REGEX +"|"+ MISC_FIRST_DATE_REGEX +"|"+ MISC_SECOND_DATE_REGEX +"|"+
			FIRST_DAY_REGEX +"|"+ SECOND_DAY_REGEX +"|"+ MISC_NUMBERED_DATE_REGEX +"|"+ NUMBERED_DATE_REGEX +"|"+ Regex.TIME_REGEX+"|"+MISC_TIME_REGEX +")";

	public static String getParsedTitle(String inputArgs) {

		if (inputArgs == null) {
			return null;
		}
		String title = getCustomTitle(inputArgs);
		return title;
	}

	private static String getCustomTitle(String inputArgs) {
		String[] strTok = inputArgs.split(NOT_TITLE_REGEX,2);
		System.out.println("title parsed = "+strTok[0]);
		String title = strTok[0].trim();
		return title;
	}

}
```
