# A0121535R
###### src\logic\commands\CommandHelp.java
``` java
 * This class contains details for help commands
 */
public class CommandHelp implements Command{
	
	private static final String TOPIC_SEPARATOR = "\r\n==================================================================\r\n";
	private static final String MESSAGE_HELP = "Welcome to help topics!";
	private static final String MESSAGE_HELP_TOPIC = "Welcome to help topic for: %s!";
	private static final String HELP_FILE_NAME = "./src/document/help.txt";
	private static final String MESSAGE_NO_HELP_CONTENT = "Sorry, the help contents will be included in our next version!";
	private static final String MESSAGE_NO_HELP_TOPIC = "Sorry, there are no help contents for this topic.";
	
	private String topic;

	public CommandType getType() {
		return CommandType.HELP;
	}
	
	public CommandHelp() {
		topic = null;
	}
	
	public CommandHelp(String topicName) {
		topic = topicName;
	}
	
	public ArrayList<String> getHelpContent() {
		if (topic != null) {
			return getHelpTopic(topic);
		} else {
			return getHelpTopics();
		}
	}
	
	public ArrayList<String> getHelpTopics() {
		ArrayList<String> result = new ArrayList<String>();
		try {
			Scanner sc = new Scanner(new File(HELP_FILE_NAME));
			while (sc.hasNextLine()) {
			    appendHelpTopic(result, sc);
			}
			return result;
		} catch (IOException e) {
			e.printStackTrace();
			result.add(MESSAGE_NO_HELP_CONTENT);
			return result;
		}
	}

	private void appendHelpTopic(ArrayList<String> list, Scanner sc) {
		String line = sc.nextLine();
		if (line.trim().equals("{")) {
			StringBuilder sb = new StringBuilder();
			line = sc.nextLine();
			while (!line.trim().equals("}")) {
				sb.append(line);
				sb.append("\r\n");
				line = sc.nextLine();
			}
			sb.append(TOPIC_SEPARATOR);
			list.add(sb.toString());
		}
	}
	
	public ArrayList<String> getHelpTopic(String topicName) {
		ArrayList<String> result = new ArrayList<String>();
		try {
			Scanner sc = new Scanner(new File(HELP_FILE_NAME));
			boolean found = false;
			while (sc.hasNextLine()) {
				boolean match = foundAndAppend(topicName, result, sc);
				if (!found) {
					found = match;
				}
			}
			sc.close();
			if (found) {
				return result;
			} else {
				result.add(MESSAGE_NO_HELP_TOPIC);
				return result;
			}
		} catch (IOException e) {
			e.printStackTrace();
			result.add(MESSAGE_NO_HELP_CONTENT);
			return result;
		}
	}

	private boolean foundAndAppend(String topicName, ArrayList<String> list,
										Scanner sc)
	{
		boolean found = false;
		String open = sc.nextLine();
		if (open.trim().equals("{")) {
			String line = sc.nextLine();
			found = line.split(":")[1].trim().equals(topicName);
			if (found) {
				StringBuilder sb = new StringBuilder();
				while (!line.trim().equals("}")) {
					sb.append(line);
					sb.append("\r\n");
					line = sc.nextLine();
				}
				sb.append(TOPIC_SEPARATOR);
				list.add(sb.toString());
			}
		}
		return found;
	}
	
	public String execute() {
		if (topic != null) {
			return String.format(MESSAGE_HELP_TOPIC, topic);
		}
		return MESSAGE_HELP;
	}
	
	public String undo() {
		return null;
	}

}
```
###### src\parser\AddParser.java
``` java
//Parser that calls the required methods for adding a task
import java.util.Calendar;
import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandInvalid;
import logic.tasks.Task;

public class AddParser extends GeneralParser {
	
	/* extracts the various parts of a Command from the given string
	 * and returns a Command object
	 * 
	 * can either add <string>
	 * or add "<title>" <rest of strings>
	 */
	public Command parse(String inputArgs){
		try{
			String notTitleToken = inputArgs;
			int[] startEndArray = new int[2];
			String title;
			boolean check = checkAbsoluteTitle(inputArgs,startEndArray);
			if(check == true){
				title=inputArgs.substring(startEndArray[0]+1,startEndArray[1]);
				notTitleToken = inputArgs.substring(startEndArray[1]+1);
			} else{
				title = getTitle(inputArgs);
			}
			Command cmdDetails = consolidateAddFields(inputArgs, notTitleToken, title);
			return cmdDetails;

		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "add processing error", e);
			return new CommandInvalid();
		}
	}
	
	//creates an Command object from the given fields
	private Command consolidateAddFields(String inputArgs, String notTitleToken, String title) {
		Calendar[] date = getDateArray(notTitleToken);
		int recurring = getRecurring(notTitleToken);
		Task task = createTask(title,date,recurring);
		Command cmdDetails = new CommandAdd(task);
		return cmdDetails;
	}
	
	//check if there is "<title>" as well as obtain the index array if true
	private static boolean checkAbsoluteTitle(String inputArgs, int[] array) {
		int absIndexStart = inputArgs.indexOf("\""); 
		if(absIndexStart>=0){
			int absIndexEnd = inputArgs.indexOf("\"",absIndexStart+1);
			if(absIndexEnd >absIndexStart && absIndexEnd>=0){
				array[0]=absIndexStart;
				array[1]=absIndexEnd;
				return true;
			}
		}
		return false;
	}

}
```
###### src\parser\CommandParser.java
``` java
//inital parser called by logic, that sort the input to the respective parser classes

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import logic.commands.Command;
import logic.commands.CommandClear;
import logic.commands.CommandDisplay;
import logic.commands.CommandGetLocation;
import logic.commands.CommandHelp;
import logic.commands.CommandInvalid;
import logic.commands.CommandLoad;
import logic.commands.CommandMark;
import logic.commands.CommandRedo;
import logic.commands.CommandType;
import logic.commands.CommandUndo;
import logic.commands.CommandUnmark;

public class CommandParser {

	public static Logger parserLogger = Logger.getLogger(CommandParser.class.getName());
	public static SimpleDateFormat sdf;
	public static CommandParser cmdParser;
	static FileHandler fh; 
	private static HashMap<String, String> displayHashmap;
	private static HashMap<String,CommandType> cmdTypeHm;

	private static final String DISPLAY_ALL ="all";
	private static final String DISPLAY_FLOAT ="float";
	private static final String DISPLAY_DEADLINE="deadline";
	private static final String DISPLAY_SESSION="session";
	private static final String DISPLAY_RECURRING="recurring";
	private static final String DISPLAY_DONE="done";
	private static final String DISPLAY_UPCOMING="upcoming";
	private static final String DISPLAY_UNDONE="undone";
	private static final String DISPLAY_PAST="past";
	private static final String DISPLAY_HELP="help";

	public CommandParser() throws SecurityException, IOException {
		sdf = new SimpleDateFormat("ddMMyyyy HHmm");
		sdf.setLenient(false);
		FileHandler fh = new FileHandler("./log/MyLogFile.txt");  
		parserLogger.addHandler(fh);
		System.out.println("where is my log file "+getClass().getClassLoader().getResource("logging.properties"));
		parserLogger.log(Level.INFO, "log starting");

	}

	public static CommandParser getInstance() throws SecurityException, IOException{
		if (cmdParser == null){
			cmdParser= new CommandParser();
			cmdParser.init();
		}
		return cmdParser;
	}

	private void init() {
		displayHashmap = new HashMap<String, String>(); 
		cmdTypeHm = new HashMap<String,CommandType>();
		displayHmInit();
		cmdTypeHmInit();
	}

	private void cmdTypeHmInit() {
		cmdHashAdd();
		cmdHashDelete();
		cmdHashEdit();
		cmdHashSearch();
		cmdHashUndo();
		cmdHashRedo();
		cmdHashSet();
		cmdHashMark();
		cmdHashUnMark();
		cmdHashGet();
		cmdHashDisplay();
		cmdHashClear();
		cmdHashHelp();	
		cmdHashLoad();
	}

	private void cmdHashEdit() {
		CommandParser.cmdTypeHm.put("edit",CommandType.EDIT);
		CommandParser.cmdTypeHm.put("e",CommandType.EDIT);
	}

	private void cmdHashSearch() {
		CommandParser.cmdTypeHm.put("search",CommandType.SEARCH);
		CommandParser.cmdTypeHm.put("s",CommandType.SEARCH);
	}

	private void cmdHashUndo() {
		CommandParser.cmdTypeHm.put("undo",CommandType.UNDO);
		CommandParser.cmdTypeHm.put("u",CommandType.UNDO);
	}

	private void cmdHashGet() {
		CommandParser.cmdTypeHm.put("get",CommandType.GET);
		CommandParser.cmdTypeHm.put("g",CommandType.GET);
		CommandParser.cmdTypeHm.put("dir",CommandType.GET);
		CommandParser.cmdTypeHm.put("cd",CommandType.GET);
	}

	private void cmdHashSet() {
		CommandParser.cmdTypeHm.put("set",CommandType.SET);
		CommandParser.cmdTypeHm.put("save",CommandType.SET);
	}

	private void cmdHashMark() {
		CommandParser.cmdTypeHm.put("mark",CommandType.MARK);
		CommandParser.cmdTypeHm.put("m",CommandType.MARK);
		CommandParser.cmdTypeHm.put("complete",CommandType.MARK);
		CommandParser.cmdTypeHm.put("finish",CommandType.MARK);
	}

	private void cmdHashDisplay() {
		CommandParser.cmdTypeHm.put("display",CommandType.DISPLAY);
		CommandParser.cmdTypeHm.put("dis",CommandType.DISPLAY);
	}

	private void cmdHashClear() {
		CommandParser.cmdTypeHm.put("clear",CommandType.CLEAR);
		CommandParser.cmdTypeHm.put("kill",CommandType.CLEAR);
	}

	private void cmdHashHelp() {
		CommandParser.cmdTypeHm.put("help",CommandType.HELP);
		CommandParser.cmdTypeHm.put("halp",CommandType.HELP);

	}

	private void cmdHashUnMark() {
		CommandParser.cmdTypeHm.put("unmark",CommandType.UNMARK);
		CommandParser.cmdTypeHm.put("um",CommandType.UNMARK);
	}

	private void cmdHashRedo() {
		CommandParser.cmdTypeHm.put("redo",CommandType.REDO);
		CommandParser.cmdTypeHm.put("r",CommandType.REDO);
	}

	private void cmdHashDelete() {
		CommandParser.cmdTypeHm.put("delete",CommandType.DELETE);
		CommandParser.cmdTypeHm.put("d",CommandType.DELETE);
		CommandParser.cmdTypeHm.put("remove",CommandType.DELETE);
	}

	private void cmdHashAdd() {
		CommandParser.cmdTypeHm.put("add",CommandType.ADD);
		CommandParser.cmdTypeHm.put("a",CommandType.ADD);
		CommandParser.cmdTypeHm.put("create",CommandType.ADD);
	}
	
	private void cmdHashLoad() {
		CommandParser.cmdTypeHm.put("load", CommandType.LOAD);
		CommandParser.cmdTypeHm.put("l", CommandType.LOAD);
	}

	private void displayHmInit() {
		displayHashAddAll();
		displayHashAddFloat();
		displayHashAddDeadline();
		displayHashAddSession();
		displayHashAddRecurring();
		displayHashAddDone();
		displayHashAddUndone();
		displayHashAddUpcoming();
		displayHashAddPast();
		displayHashAddHelp();
	}

	private void displayHashAddHelp() {
		CommandParser.displayHashmap.put(DISPLAY_HELP, DISPLAY_HELP);
		CommandParser.displayHashmap.put("halp",DISPLAY_HELP);
	}


	private void displayHashAddPast() {
		CommandParser.displayHashmap.put(DISPLAY_PAST, DISPLAY_PAST);
	}


	private void displayHashAddUpcoming() {
		CommandParser.displayHashmap.put(DISPLAY_UPCOMING, DISPLAY_UPCOMING);
		CommandParser.displayHashmap.put("coming", DISPLAY_UPCOMING);

	}


	private void displayHashAddUndone() {
		CommandParser.displayHashmap.put(DISPLAY_UNDONE, DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("uncompleted", DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("unfinished", DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("pending", DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("incomplete", DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("in progress", DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("uncomplete", DISPLAY_UNDONE);
		CommandParser.displayHashmap.put("incompleted", DISPLAY_UNDONE);
	}


	private void displayHashAddDone() {
		CommandParser.displayHashmap.put(DISPLAY_DONE, DISPLAY_DONE);
		CommandParser.displayHashmap.put("completed", DISPLAY_DONE);
		CommandParser.displayHashmap.put("finished", DISPLAY_DONE);
		CommandParser.displayHashmap.put("complete", DISPLAY_DONE);
	}


	private void displayHashAddRecurring() {
		CommandParser.displayHashmap.put("repeating", DISPLAY_RECURRING);
		CommandParser.displayHashmap.put("routine", DISPLAY_RECURRING);
		CommandParser.displayHashmap.put(DISPLAY_RECURRING, DISPLAY_RECURRING);
		CommandParser.displayHashmap.put("repeat", DISPLAY_RECURRING);
		CommandParser.displayHashmap.put("recur", DISPLAY_RECURRING);
	}


	private void displayHashAddSession() {
		CommandParser.displayHashmap.put(DISPLAY_SESSION, DISPLAY_SESSION);
		CommandParser.displayHashmap.put("event",  DISPLAY_SESSION);
	}


	private void displayHashAddDeadline() {
		CommandParser.displayHashmap.put(DISPLAY_DEADLINE,DISPLAY_DEADLINE);
		CommandParser.displayHashmap.put("normal", DISPLAY_DEADLINE);
		CommandParser.displayHashmap.put("norm", DISPLAY_DEADLINE);
	}


	private void displayHashAddFloat() {
		CommandParser.displayHashmap.put(DISPLAY_FLOAT, DISPLAY_FLOAT);
		CommandParser.displayHashmap.put("undecided",DISPLAY_FLOAT );
		CommandParser.displayHashmap.put("floating", DISPLAY_FLOAT);
	}


	private void displayHashAddAll() {
		CommandParser.displayHashmap.put("", DISPLAY_ALL);
		CommandParser.displayHashmap.put(DISPLAY_ALL,DISPLAY_ALL);
	}
	
	/*
	 * It obtains the command type then calls the other parser classes to obtain the Command Object.
	*/
	public static Command parseInput(String input) {
		try{
			if (cmdParser == null){
				cmdParser= new CommandParser();
				cmdParser.init();
			}
		} catch( SecurityException e){
			e.printStackTrace();
		} catch (IOException e){
			e.printStackTrace();
		}
		String[] inputTokens = getToken(input);
		CommandType cmd = getCmdType(inputTokens[0]);
		if(inputTokens.length==2){
			return getInputLengthTwo(inputTokens, cmd);
		} else if(inputTokens.length==1){
			return getInputLengthOne(cmd);
		} else{
			return new CommandInvalid();
		}
	}

	private static Command getInputLengthOne(CommandType cmd) {
		try{
			switch(cmd){

				case REDO:
					return new CommandRedo();

				case UNDO:
					return new CommandUndo();

				case HELP:
					return new CommandHelp();

				case CLEAR:
					return new CommandClear();

				case GET:
					return new CommandGetLocation();

				default:
					return new CommandInvalid();
			}
		} catch(NullPointerException e){
			return new CommandInvalid();
		}
	}

	private static Command getInputLengthTwo(String[] inputTokens, CommandType cmd) {
		try{
			switch(cmd){
				case ADD:
					AddParser ap = new AddParser();
					return ap.parse(inputTokens[1]);

				case DELETE:
					DeleteParser dp =DeleteParser.getInstance();
					return dp.parse(inputTokens[1]);

				case EDIT:
					EditParser ep = EditParser.getInstance();
					return ep.parse(inputTokens[1]);

				case MARK:
					int inputNum = getInputNum(inputTokens[1]);
					if(inputNum==-1){
						return new CommandInvalid();
					}
					return new CommandMark(inputNum);

				case UNMARK:
					inputNum = getInputNum(inputTokens[1]);
					if(inputNum==-1){
						return new CommandInvalid();
					}
					return new CommandUnmark(inputNum);

				case SET:
					SetParser setParser = new SetParser();
					return setParser.parse(inputTokens[1]);

				case SEARCH:
					SearchParser searchP = new SearchParser();
					return searchP.parse(inputTokens[1]);

				case DISPLAY:
					return getDisplayCommand(inputTokens[1]);
				
				case HELP:
					return new CommandHelp(inputTokens[1]);
				case LOAD:
					return new CommandLoad(inputTokens[1]);

				default:
					return new CommandInvalid();
			}
		} catch (NullPointerException e){
			return new CommandInvalid();
		}
	}


	private static int getInputNum(String input) {
		int num =-1;
		try{
			num = Integer.parseInt(input);
			return num;
		} catch(NumberFormatException e){
			num=-1;
			return num;
		}
	}


	private static Command getDisplayCommand(String input) {
		input=input.toLowerCase();
		input=input.trim();
		System.out.println("input at cmdParser is "+input);
		String returnString;

		try{
			returnString = displayHashmap.get(input);
		} catch(NullPointerException e){
			System.out.println("returnstring is null");
			returnString=null;
		}

		if(returnString==DISPLAY_HELP){
			return new CommandHelp();
		} else if(returnString==null){
			return new CommandInvalid();
		} else{
			CommandDisplay cmdDisplay = new CommandDisplay(returnString);
			return cmdDisplay;
		}
	}


	private static String[] getToken(String input) {
		input = input.trim();
		input=input.replaceAll(Regex.REGEX_SPACE," ");
		String[] inputTokens = input.split(" ",2); 
		return inputTokens;
	}


	private static CommandType getCmdType(String string) {
		string = string.toLowerCase();
		string = string.trim();
		try{
			CommandType cmdType = cmdTypeHm.get(string);
			return cmdType;
		} catch (NullPointerException e){
			return CommandType.INVALID;
		}
	}
}
```
###### src\parser\DateParser.java
``` java
// parser that obtains the different date Strings then use natty parser to parse
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang.time.DateUtils;

public class DateParser {

	static final String START_DATE_KEYWORD = "(" + "((?<=\\s|^)(at?|from?))?" + ")";
	static final String CONNECT_DATE_KEYWORD =  "(to |till |until )";

	static final String ALL_DATE_REGEX = "("+ TitleParser.FIRST_DATE_REGEX +"|"+ TitleParser.SECOND_DATE_REGEX +"|"+ TitleParser.MISC_FIRST_DATE_REGEX +"|"+ TitleParser.MISC_SECOND_DATE_REGEX +"|"+
			TitleParser.FIRST_DAY_REGEX +"|"+ TitleParser.SECOND_DAY_REGEX +"|"+ TitleParser.MISC_NUMBERED_DATE_REGEX +"|"+ TitleParser.NUMBERED_DATE_REGEX +")";
	
	//initial method called by other parser classes
	public static Calendar[] getDates(String input) {
		ArrayList<String> dateList = new ArrayList<String>();
		ArrayList<String> timeList = new ArrayList<String>();
		Calendar[] cal =  getCalendar(input, dateList, timeList);
		return cal;
	}
	
	/*obtain the part of the string that has to do with dates
	* and obtain the part of the string that has to do with times
	*/
	private static Calendar[] getCalendar(String input, ArrayList<String> dateList, ArrayList<String> timeList) {
		extractDays(input, dateList); 
		extractTimes(input, timeList); 
		Calendar[] cal = sortByDateSize(dateList, timeList);
		return cal;
	}
	
	//extract any part of the string related to time
	private static void extractTimes(String input, ArrayList<String> timeList) {
		Pattern pattern;
		Matcher matcher;
		pattern = Pattern.compile(Regex.TIME_REGEX);
		matcher = pattern.matcher(input);	
		getTimes(timeList, matcher);
	}
	
	//extract any part of the string related to day
	private static void extractDays(String input, ArrayList<String> dateList) {
		Pattern pattern = Pattern.compile(ALL_DATE_REGEX);
		Matcher matcher = pattern.matcher(input);	
		getDays(dateList, matcher);
	}
	
	//sort by the number of dates input
	//e.g 15 may and/or 03/03/2013
	private static Calendar[] sortByDateSize(ArrayList<String> dateList, ArrayList<String> timeList) {
		try{
			if(dateList.size()==2){
				Date[] dates = dateSizeTwo(dateList, timeList);
				return convertFromDate(dates); 
			} else if(dateList.size()==0){
				Calendar[] cal = dateSizeZero(timeList);
				return cal;
			} else {
				return dateSizeOne(dateList, timeList);
			}
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "date nullpointer error", e);
			return convertFromDate(new Date[0]);
		}
	}
	
	//if input date is only one
	private static Calendar[] dateSizeOne(ArrayList<String> dateList, ArrayList<String> timeList) {
		String startTime;
		String endTime;
		if(timeList.size()==2){
			Date[] dates = new Date[2];
			startTime = timeList.get(0)+" "+dateList.get(0);
			endTime= timeList.get(1) +" "+dateList.get(0);
			obtainDatesArray(startTime, endTime, dates);
			return convertFromDate(dates); 
		} else if(timeList.size()==0){
			Date[] dates = new Date[1];
			startTime = dateList.get(0);
			dates[0]=NattyDateParser.getDate(startTime);
			return convertFromDate(dates); 
		} else{
			Date[] dates = new Date[1];
			startTime = timeList.get(0)+" "+dateList.get(0);
			dates[0]=NattyDateParser.getDate(startTime);
			return convertFromDate(dates); 
		}
	}
	
	//if no input date
	private static Calendar[] dateSizeZero(ArrayList<String> timeList) {
		String startTime;
		String endTime;
		if(timeList.size()==2){
			Date[] dates = new Date[2];
			startTime = timeList.get(0);
			endTime= timeList.get(1);
			obtainDatesArray(startTime, endTime, dates);
			return convertFromDate(dates); 
		} else if(timeList.size()==0){
			return convertFromDate(new Date[0]);
		} else{
			Date[] dates = new Date[1];
			startTime = timeList.get(0);
			dates[0]=NattyDateParser.getDate(startTime);
			return convertFromDate(dates); 
		}
	}
	
	//if input date is two
	private static Date[] dateSizeTwo(ArrayList<String> dateList, ArrayList<String> timeList) {
		String startTime;
		String endTime;
		Date[] dates = new Date[2];
		if(timeList.size()==2){		
			startTime = obtainFullDateString(timeList.get(0),dateList.get(0));
			endTime = obtainFullDateString(timeList.get(1),dateList.get(1));
			obtainDatesArray(startTime, endTime, dates);
		} else if(timeList.size()==0){
			startTime = dateList.get(0);
			endTime = dateList.get(1);
			obtainDatesArray(startTime, endTime, dates);
		} else{
			startTime = obtainFullDateString(timeList.get(0),dateList.get(0));
			endTime = obtainFullDateString(timeList.get(0),dateList.get(1));
			obtainDatesArray(startTime, endTime, dates);
		}
		return dates;
	}
	
	//concat the time and date together
	private static String obtainFullDateString (String time , String date){
		String string = time+" "+date;
		return string;
	}
	
	private static void obtainDatesArray(String startTime, String endTime, Date[] dates) {
		dates[0]=NattyDateParser.getDate(startTime);
		dates[1]=NattyDateParser.getDate(endTime);
	}

	private static void getTimes(ArrayList<String> timeList, Matcher matcher) {
		while (matcher.find( )) {
			System.out.println("Found TIME value: " + matcher.group() );
			timeList.add(matcher.group());
		}
	}

	private static void getDays(ArrayList<String> dateList, Matcher matcher) {
		while (matcher.find( )) {
			System.out.println("Found DATE value: " + matcher.group() );
			dateList.add(matcher.group());
		}
	}
	
	//convert date object to calendar object
	public static Calendar[] convertFromDate(Date[] dates) {
		Calendar[] result = new Calendar[dates.length];
		for (int i=0; i<dates.length; i++) {
			Calendar cal = obtainCalendarDates(dates, result, i);
			System.out.println(cal);
		}
		return result;
	}

	private static Calendar obtainCalendarDates(Date[] dates, Calendar[] result, int i) {
		Calendar cal;
		Date date = dates[i];
		cal = getCal(date);
		result[i] = cal;
		return cal;
	}
	

	private static Calendar getCal(Date date) {
		Calendar cal;
		if (date != null) {
			cal = Calendar.getInstance();
			cal.setTime(DateUtils.truncate(date, Calendar.SECOND));
		} else {
			cal = null;
		}
		return cal;
	}



}
```
###### src\parser\DeleteParser.java
``` java
//Parser for deleting a task

import java.util.HashSet;
import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandDelete;
import logic.commands.CommandDeleteRecurring;
import logic.commands.CommandInvalid;

public class DeleteParser extends GeneralParser {

	private static DeleteParser dp;
	private HashSet<String> dpHs;
	
	// Returns a Command object 
	public Command parse(String inputArgs){
		inputArgs=inputArgs.trim();
		inputArgs=inputArgs.toLowerCase();
		String[] inputTokens = inputArgs.split(Regex.REGEX_SPACE);
		return obtainDeleteCommand(inputArgs, inputTokens);
	}
	
	//check the size of the input string after the command type
	private Command obtainDeleteCommand(String inputArgs, String[] inputTokens) {
		if(inputTokens.length ==2){
			return getRecurringDelete(inputArgs, inputTokens);
		} else{
			return getNormalDelete(inputArgs);	
		}
	}
	
	//returns a normal CommandDelete if there is no recurring keyword
	private Command getNormalDelete(String inputArgs) {
		Command cmdDetails;
		try{
			int inputNum = getInputNum(inputArgs);
			boolean checkSize = checkInputArgs(inputArgs,1);
			if(inputNum<1||!checkSize){
				return cmdDetails = new CommandInvalid();
			}
			cmdDetails = new CommandDelete(inputNum);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "normal delete nullpointer error", e);
			cmdDetails = new CommandInvalid();
			return cmdDetails;
		} catch(NumberFormatException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "normal delete numberFormat error", e);
			cmdDetails = new CommandInvalid();
			return cmdDetails;
		}
	}
	
	//returns a reccuring delete if there is recurring keyword
	private Command getRecurringDelete(String inputArgs, String[] inputTokens) {
		Command cmdDetails;
		try{
			if(dpHs.contains(inputTokens[0])){
				return obtainRecurringDelete(inputArgs, inputTokens);
			} else{
				cmdDetails = new CommandInvalid();
				return cmdDetails;
			}
		}catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "recurring delete error", e);
			cmdDetails = new CommandInvalid();
			return cmdDetails;
		}
	}

	private Command obtainRecurringDelete(String inputArgs, String[] inputTokens) {
		Command cmdDetails;
		int inputNum = getInputNum(inputTokens[1]);
		boolean checkSize = checkInputArgs(inputArgs,2);
		if(inputNum<1||!checkSize){
			cmdDetails = new CommandInvalid();
			return cmdDetails;
		} else{
			cmdDetails = new CommandDeleteRecurring(inputNum);
			return cmdDetails;
		}
	}

	private void init() {	
		dpHs = new HashSet<String>();
		dpHs.add("repeating");
		dpHs.add("routine");
		dpHs.add("recurring");
		dpHs.add("repeat");
		dpHs.add("recur");
	}

	public static DeleteParser getInstance() {
		if (dp == null){
			dp= new DeleteParser();
			dp.init();
		}
		return dp;
	}
}
```
###### src\parser\EditParser.java
``` java
//Parser for editing a task

import java.util.Calendar;
import java.util.HashSet;
import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandEdit;
import logic.commands.CommandInvalid;
import logic.commands.CommandEditRecurring;
import logic.tasks.Task;

public class EditParser extends GeneralParser {

	private static EditParser ep;
	private HashSet<String> epHs;

	//Returns a command object
	protected Command parse(String inputArgs){
		try{
			inputArgs=inputArgs.trim();
			inputArgs=inputArgs.toLowerCase();

			String[] inputTokens = inputArgs.split(Regex.REGEX_SPACE,2);

			if(epHs.contains(inputTokens[0])){
				return getRecurringEdit(inputTokens);
			} else{
				return getNormalEdit(inputTokens);
			}
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "edit processing error", e);
			return new  CommandInvalid();
		}

	}

	//returns CommandRecurringEdit
	private Command getRecurringEdit(String[] inputTokens) {
		Command cmdDetails;
		try{
			String[] recurringInputTokens = inputTokens[1].split(Regex.REGEX_SPACE,2);
			int inputNum = getInputNum(recurringInputTokens[0]);
			Task task = getEditTask(recurringInputTokens[1]);
			if(task ==null){
				return new CommandInvalid();
			}
			cmdDetails= new CommandEditRecurring(inputNum,task);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "edit null pointer error", e);
			return new  CommandInvalid();
		} catch(ArrayIndexOutOfBoundsException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "edit array index out of bound error", e);
			return new  CommandInvalid();
		}
	}

	//returns CommandEdit
	private Command getNormalEdit(String[] inputTokens) {
		Command cmdDetails;
		try{
			int inputNum = getInputNum(inputTokens[0]);
			Task task = getEditTask(inputTokens[1]);
			if(task ==null){
				return new CommandInvalid();
			}
			cmdDetails = new CommandEdit(inputNum,task);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "edit processing error", e);
			return new  CommandInvalid();
		}
	}

	private Task getEditTask(String inputArgs) {
		String notTitleToken = inputArgs;
		int[] startEndArray = new int[2];
		String title=null;
		boolean check = checkAbsoluteTitle(inputArgs,startEndArray);
		if(check == true){
			title=inputArgs.substring(startEndArray[0]+1,startEndArray[1]);
			notTitleToken = inputArgs.substring(startEndArray[1]+1);
		}
		Task task = consolidateEditFields(inputArgs, notTitleToken, title);
		return task;
	}

	//creates an Command object from the given fields
	private Task consolidateEditFields(String inputArgs, String notTitleToken, String title) {
		Calendar[] date = getDateArray(notTitleToken);
		int recurring = getRecurring(inputArgs);
		Task task = createTask(title,date,recurring);
		return task;
	}

	//check if there is "<title>" as well as obtain the index array if true
	private static boolean checkAbsoluteTitle(String inputArgs, int[] array) {
		int absIndexStart = inputArgs.indexOf("\""); 
		if(absIndexStart>=0){
			int absIndexEnd = inputArgs.indexOf("\"",absIndexStart+1);
			if(absIndexEnd >absIndexStart && absIndexEnd>=0){
				array[0]=absIndexStart;
				array[1]=absIndexEnd;
				return true;
			}
		}
		return false;
	}


	private void init() {	
		epHs = new HashSet<String>();
		epHs.add("repeating");
		epHs.add("routine");
		epHs.add("recurring");
		epHs.add("repeat");
		epHs.add("recur");
	}

	public static EditParser getInstance() {
		if (ep == null){
			ep= new EditParser();
			ep.init();
		}
		return ep;
	}

}
```
###### src\parser\GeneralParser.java
``` java
//parser class with the general methods

import java.util.Calendar;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import logic.commands.Command;
import logic.tasks.Task;
import logic.tasks.TaskUtil;

public abstract class GeneralParser {


	protected abstract Command parse(String inputArgs);

	//Obtain title from input
	protected String getTitle(String input){
		String title = TitleParser.getParsedTitle(input);
		return title;
	}

	//Obtain dates from input
	protected Calendar[] getDateArray(String input){
		Calendar[] dates = DateParser.getDates(input);
		return dates;
	}

	//Obtain number from input
	protected int getInputNum(String inputArgs) {
		int num = InputNumParser.getInputNum(inputArgs);
		return num;
	}

	protected boolean checkInputArgs(String inputArgs, int size){
		String[] inputToken = inputArgs.split(Regex.REGEX_SPACE);
		if(inputToken.length<size){
			return false;
		}
		return true;
	}

	//Return a task object from the given fields
	protected Task createTask(String title, Calendar[] dates, int recurringPeriod) {
		System.out.println("Recurring! "+recurringPeriod);
		if (dates.length == 0) {
			if(title==null){
				System.out.println("Recurring only ! "+recurringPeriod);
			}
			return TaskUtil.getInstance(title, recurringPeriod);
		} else if (dates.length == 1) {
			return TaskUtil.getInstance(title, dates[0],recurringPeriod);
		} else {
			return TaskUtil.getInstance(title, dates[0], dates[1], recurringPeriod);
		}
	}

	//Obtain the int values that represents the recurring dates
	protected static int getRecurring(String inputArgs){
		inputArgs = inputArgs.toLowerCase();

		if(inputArgs.contains("every day")){
			return 1;
		} else if(inputArgs.contains("every week")){
			return 7;
		} else if(inputArgs.contains("every month")){
			return -1;
		} else if(inputArgs.contains("every year")){
			return -2;
		} else{
			int num = getCustomPeriod(inputArgs);
			return num;
		}

	}

	//Obtain user input number recurring periods
	private static int getCustomPeriod(String inputArgs) {

		int num = 0;

		num = getCustomDays(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomWeeks(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomMonths(inputArgs);
		if(num!=0){
			return num;
		}
		num = getCustomYears(inputArgs);
		if(num!=0){
			return num;
		}
		return num;
	}


	private static int getCustomYears(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_YEAR_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=-2*num;
		}
		return num;
	}


	private static int getCustomMonths(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_MONTH_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=(1-2*num);
		}
		return num;
	}


	private static int getCustomWeeks(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_WEEK_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
			num=num*7;
		}
		return num;
	}


	private static int getCustomDays(String inputArgs) {
		int num=0;  
		Pattern pattern = Pattern.compile(Regex.PERIOD_DAY_REGEX_MUL);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
			num = getPeriod(matcher.group());
		}
		return num;
	}


	private static int getPeriod(String inputArgs) {
		Pattern pattern = Pattern.compile(Regex.NUM_REGEX);
		Matcher matcher = pattern.matcher(inputArgs);
		if (matcher.find( )) {
			System.out.println("Found value: " + matcher.group() );
		}
		int num = Integer.parseInt(matcher.group());
		return num;
	}

}
```
###### src\parser\InputNumParser.java
``` java
//class for getting an input number

import java.util.logging.Level;

public class InputNumParser {

	private static final String REGEX_SPACE = "\\s";

	public static int getInputNum(String inputArgs) {
		String[] inputTokens = inputArgs.split(REGEX_SPACE);
		String inputNum=inputTokens[0];
		int num;
		try{
			num=Integer.parseInt(inputNum);
		} catch(NumberFormatException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "inputNumParser no inputnum", e);
			num=0;
		}
		if(num<1){
			num=0;
		}
		return num;
	}
}
```
###### src\parser\NattyDateParser.java
``` java
// Parser for using external library natty to get Date

import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class NattyDateParser {

	public static Date getDate(String input) {
		Date date = null;
		Parser parser = new Parser();
		List<DateGroup> dateGroup= parser.parse(input);
		if (dateGroup.isEmpty()) { 
			System.out.println(date);
			return null; 
		}
		List<Date> dates = dateGroup.get(0).getDates();
		date = dates.get(0);
		System.out.println(date);
		return date;
	}

}
```
###### src\parser\Regex.java
``` java
// class  that contains the general Regex

public class Regex {
	static final String REGEX_SPACE = "(\\s+)";
	static final String START = "(?<=^|\\s)";
	static final String END = "(?=\\s|$)";
	static final String MISC_REGEX =START+"(from?|to?|till?|until?|by?|on?|next?|this?|by next?|by this?)?";
	static final String MONTHNAME = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)";
	static final String DATES = "(\\d?\\d)(?:st|rd|nd|th)?";
	static final String YEAR = "(\\d{2}|\\d{4})?";
	static final String DATE_MONTH_REGEX = "(?<=\\s|^)" + DATES + REGEX_SPACE + MONTHNAME + END;
	static final String MONTH_DATE_REGEX = "(?<=\\s|^)" + MONTHNAME +REGEX_SPACE + DATES + END;
	static final String DATE_MONTH_YEAR_REGEX = "(?<=\\s|^)" + DATES + REGEX_SPACE+ MONTHNAME + REGEX_SPACE + YEAR + END;
	static final String MONTH_DATE_YEAR_REGEX = "(?<=\\s|^)" + MONTHNAME +REGEX_SPACE + DATES + REGEX_SPACE + YEAR + END;
	static final String TMR_REGEX = "(today?|tmr?|tomorrow?)";
	static final String DAYNAME = "(next week?|next month?|mon(?:day)?|tue(?:sday)?|wed(?:nesday)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)";
	static final String TWELVE_HR_REGEX = "([0-9]?[0-9])([.:][0-9][0-9])?\\s?(am|pm)";
	static final String TWENTYFOUR_HR_REGEX = "(([0-9]?[0-9])[:]([0-9][0-9]))\\s?[?:h|H]?";
	static final String NUM_REGEX= "(\\d+)";
	static final String TIME_REGEX = "(" + Regex.TWELVE_HR_REGEX + "|" + Regex.TWENTYFOUR_HR_REGEX + ")";
	static final String DAY = "(\\d?\\d)";
	static final String MONTH = "(\\d?\\d)";
	static final String DATE_SEP = "[-/]";
	static final String PERIOD_DAY_REGEX = "every"+REGEX_SPACE+"day" + END;
	static final String PERIOD_WEEK_REGEX ="every"+REGEX_SPACE+"week" + END;
	static final String PERIOD_MONTH_REGEX ="every"+REGEX_SPACE+"month" + END;
	static final String PERIOD_YEAR_REGEX ="every"+REGEX_SPACE+"year" + END;
	static final String PERIOD_DAY_REGEX_MUL = "every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(day|days)" + END;
	static final String PERIOD_WEEK_REGEX_MUL ="every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(week|weeks)" + END;
	static final String PERIOD_MONTH_REGEX_MUL ="every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(month|months)" + END;
	static final String PERIOD_YEAR_REGEX_MUL ="every"+REGEX_SPACE+"(\\d+)"+REGEX_SPACE+"(year|years)" + END;
	static final String RECURRING_REGEX= START+PERIOD_DAY_REGEX+ "|"+ START+PERIOD_WEEK_REGEX +"|"+START+PERIOD_MONTH_REGEX+"|"+START+PERIOD_YEAR_REGEX;
	static final String RECURRING_REGEX_MUL=START+PERIOD_DAY_REGEX_MUL+ "|" +START+PERIOD_WEEK_REGEX_MUL +"|"+START+PERIOD_MONTH_REGEX_MUL+"|"+START+PERIOD_YEAR_REGEX_MUL;
	static final String RECURRING_REGEX_FINAL = RECURRING_REGEX+"|"+RECURRING_REGEX_MUL;
}
```
###### src\parser\SearchParser.java
``` java
//Parser for search command

import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSearch;

public class SearchParser extends GeneralParser {

	protected Command parse(String inputArgs){
		try{
			Command cmdDetails =null;
			String searchKey = inputArgs;
			if(searchKey.equals("")||searchKey==null){
				return cmdDetails = new CommandInvalid();
			}
			cmdDetails = new CommandSearch(searchKey);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "searchparser nullpointer error", e);
			return new CommandInvalid();
		}

	}
}
```
###### src\parser\SetParser.java
``` java
//Parser for returning storage directory string

import java.util.logging.Level;
import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSetLocation;

public class SetParser extends GeneralParser{

	public Command parse(String inputArgs) {
		try{
			Command cmdDetails =null;
			String stringPath = inputArgs;
			if(stringPath.equals("")||stringPath==null){
				return cmdDetails = new CommandInvalid();
			}
			cmdDetails = new CommandSetLocation(stringPath);
			return cmdDetails;
		} catch(NullPointerException e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "set Parser nullpointer error", e);
			return new CommandInvalid();
		}

	}
}
```
###### src\parser\TitleParser.java
``` java
//obtains the title from input string

public class TitleParser {
	static final String NO_YEAR_FORMATTED_DATE_REGEX = Regex.START + Regex.DAY + "[-/]" + Regex.MONTH + Regex.END;
	static final String MISC_NO_YEAR_FORMATTED_DATE_REGEX = Regex.START+Regex.MISC_REGEX+Regex.REGEX_SPACE+ Regex.DAY + "[-/]" + Regex.MONTH + Regex.END;
	static final String FORMATTED_DATE_WITH_YEAR_REGEX = Regex.START + Regex.DAY + Regex.DATE_SEP + Regex.MONTH + Regex.DATE_SEP + Regex.YEAR + Regex.END;
	static final String MISC_FORMATTED_DATE_WITH_YEAR_REGEX = Regex.START +Regex.MISC_REGEX+Regex.REGEX_SPACE+ Regex.DAY + Regex.DATE_SEP + Regex.MONTH + Regex.DATE_SEP + Regex.YEAR + Regex.END;
	static final String NUMBERED_DATE_REGEX = NO_YEAR_FORMATTED_DATE_REGEX + "|" + FORMATTED_DATE_WITH_YEAR_REGEX+"|"+MISC_NO_YEAR_FORMATTED_DATE_REGEX+"|"+MISC_FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String MISC_NUMBERED_DATE_REGEX = Regex.MISC_REGEX+NO_YEAR_FORMATTED_DATE_REGEX + "|" + Regex.MISC_REGEX+FORMATTED_DATE_WITH_YEAR_REGEX;
	static final String FIRST_DATE_REGEX = Regex.DATE_MONTH_YEAR_REGEX+ "|" + Regex.MONTH_DATE_YEAR_REGEX+"|"+Regex.MONTH_DATE_REGEX+"|"+Regex.DATE_MONTH_REGEX;
	static final String MISC_FIRST_DATE_REGEX =  Regex.DATE_MONTH_YEAR_REGEX+ "|" + Regex.MONTH_DATE_YEAR_REGEX;
	static final String SECOND_DATE_REGEX=Regex.MISC_REGEX+ Regex.DATE_MONTH_REGEX+ "|" + Regex.MISC_REGEX+Regex.MONTH_DATE_REGEX;
	static final String MISC_SECOND_DATE_REGEX = Regex.MISC_REGEX+ Regex.DATE_MONTH_YEAR_REGEX+ "|" +Regex.MISC_REGEX+ Regex.MONTH_DATE_YEAR_REGEX;
	static final String FIRST_DAY_REGEX=Regex.START+Regex.MISC_REGEX+Regex.REGEX_SPACE+Regex.TMR_REGEX+ Regex.END +"|"+Regex.START+Regex.TMR_REGEX+ Regex.END ;

	static final String MISC_TIME_REGEX = Regex.MISC_REGEX + Regex.TWELVE_HR_REGEX + "|" + Regex.MISC_REGEX+ Regex.TWENTYFOUR_HR_REGEX;
	static final String SECOND_DAY_REGEX=Regex.MISC_REGEX +Regex.REGEX_SPACE+ Regex.DAYNAME+Regex.END+"|"+Regex.DAYNAME+ Regex.END;

	static final String NOT_TITLE_REGEX = "("+ Regex.RECURRING_REGEX_FINAL +"|"+ FIRST_DATE_REGEX +"|"+ SECOND_DATE_REGEX +"|"+ MISC_FIRST_DATE_REGEX +"|"+ MISC_SECOND_DATE_REGEX +"|"+
			FIRST_DAY_REGEX +"|"+ SECOND_DAY_REGEX +"|"+ MISC_NUMBERED_DATE_REGEX +"|"+ NUMBERED_DATE_REGEX +"|"+ Regex.TIME_REGEX+"|"+MISC_TIME_REGEX +")";

	public static String getParsedTitle(String inputArgs) {

		if (inputArgs == null) {
			return null;
		}
		String title = getTitle(inputArgs);
		return title;
	}

	private static String getTitle(String inputArgs) {
		String[] strTok = inputArgs.split(NOT_TITLE_REGEX,2);
		System.out.println("title parsed = "+strTok[0]);
		String title = strTok[0].trim();
		return title;
	}

}
```
