# A0121535R
###### src\logic\commands\CommandHelp.java
``` java
 * This class contains details for help commands
 */
public class CommandHelp implements Command{
	public CommandType getType() {
		return CommandType.HELP;
	}
	
	public String execute() {
		return null;
	}
	
	public String undo() {
		return null;
	}

}
```
###### src\Parser\AddParser.java
``` java
* Parser for adding a task
*/
import java.util.Date;
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandInvalid;
import logic.commands.CommandType;
import logic.tasks.Deadline;

public class AddParser extends GeneralParser {
	
	public Command parse(String inputArgs){
		try{
		String title = getTitle(inputArgs);
		Date date = getDate(inputArgs);
		//String description = getDescription(inputArgs);
		Deadline task = new Deadline(title,date);
		Command cmdDetails = new CommandAdd(task);
		
		return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}
	
		
	}
}
```
###### src\Parser\CommandParser.java
``` java
 * inital parser that sort the input to the respective parser classes
 */
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import logic.commands.Command;
import logic.commands.CommandClear;
import logic.commands.CommandDisplay;
import logic.commands.CommandHelp;
import logic.commands.CommandInvalid;
import logic.commands.CommandType;
import logic.commands.CommandUndo;

public class CommandParser {

	private static final String REGEX_SPACE = "\\s+";

	public static Logger parserLogger = Logger.getLogger(CommandParser.class.getName());
	public ArrayList<String> list;
	public static SimpleDateFormat sdf;

	public static CommandParser cmdParser;
	FileHandler fh; 

	public CommandParser() throws SecurityException, IOException {
		list = new ArrayList<String>();
		sdf = new SimpleDateFormat("ddMMyyyy HHmm");
		sdf.setLenient(false);
		FileHandler fh = new FileHandler("./log/MyLogFile.txt");  
		parserLogger.addHandler(fh);
		System.out.println("where is my log file "+getClass().getClassLoader().getResource("logging.properties"));
		parserLogger.log(Level.INFO, "log starting");

	}


	public static CommandParser getInstance() throws SecurityException, IOException{
		if (cmdParser == null){
			cmdParser= new CommandParser();
		}
		return cmdParser;
	}

	/**for add
	 * Requires input format <add> <title> <date> 
	 * for e.g add meet at john's house at next wednesday
	 * 
	 * for delete
	 * Requires input format <delete> <num>
	 * for e.g delete 2
	 * 
	 * for edit
	 * Requires input format <edit> <num> <title>/<date>
	 * for e.g edit 3 meet at jack's place 
	 * or edit 3 at next tuesday
	 * should check the value of TASK to see if the respective title and date fields 
	 * are null or not.
	 * 
	 * for mark
	 * Requires input format <mark> <num>
	 * for e.g mark 1
	 * 
	 * for unmark
	 * Requires input format <unmark> <num>
	 * for e.g unmark 1
	 * 
	 * for undo
	 * inputformat <undo>
	 */
	public static Command parseInput(String input) {
		String[] inputTokens = getToken(input);
		CommandType cmd = getCmdType(inputTokens[0]);
		Command cmdDetails=null;

		if(inputTokens.length==2){
			switch(cmd){

			case ADD:
				AddParser ap = new AddParser();
				return cmdDetails = ap.parse(inputTokens[1]);

			case DELETE:
				DeleteParser dp = new DeleteParser();
				return cmdDetails = dp.parse(inputTokens[1]);

			case EDIT:
				EditParser ep = new EditParser();
				return cmdDetails = ep.parse(inputTokens[1]);

				/*	
			case MARK:
				inputNum = getInputNum(inputTokens);
				if(inputNum==-1){
					cmd=CommandType.INVALID;
				}
				cmdDetails= new CommandDetails(cmd,task,inputNum);
				break;

			case UNMARK:
				inputNum = getInputNum(inputTokens);
				if(inputNum==-1){
					cmd=CommandType.INVALID;
				}
				cmdDetails= new CommandDetails(cmd,task,inputNum);
				break;
				 */
			case SET:
				SetParser setParser = new SetParser();
				return cmdDetails = setParser.parse(inputTokens[1]);
				
			case SEARCH:
				SearchParser searchP = new SearchParser();
				return cmdDetails = searchP.parse(inputTokens[1]);
	
			default:
				return cmdDetails = new CommandInvalid();
			}
		}
		else if(inputTokens.length==1){
			switch(cmd){			
			case UNDO:
				return cmdDetails = new CommandUndo();

			case HELP:
				return cmdDetails =  new CommandHelp();
	
			case CLEAR:
				return cmdDetails = new CommandClear();

			case DISPLAY:
				return cmdDetails = new CommandDisplay();
	
			default:
				return cmdDetails = new CommandInvalid();
			}
		}
		else{
			return cmdDetails = new CommandInvalid();
		}
	}


	private static String[] getToken(String input) {
		input = input.trim();
		input=input.replaceAll(REGEX_SPACE," ");
		String[] inputTokens = input.split(" ",2); 
		return inputTokens;
	}


	private static CommandType getCmdType(String string) {
		string = string.toLowerCase();
		switch (string) {
		case "a":
		case "add":
			return CommandType.ADD;
		case "d":
		case "delete":
			return CommandType.DELETE;
		case "u":
		case "undo":
			return CommandType.UNDO;
		case "m":
		case "mark":
			return CommandType.MARK;
		case "um":
		case "unmark":
			return CommandType.UNMARK;
		case "e":
		case "edit":
			return CommandType.EDIT;
		case "s":
		case "search":
			return CommandType.SEARCH;
		case "h":
		case "help":
			return CommandType.HELP;
		case "c":
		case "clear":
			return CommandType.CLEAR;
		case "set":
			return CommandType.SET;
		case "dis":
		case "display":
			return CommandType.DISPLAY;
		default:
			return CommandType.INVALID;
		}
	}
}
```
###### src\Parser\DateParser.java
``` java
* Parser for using natty to get Date
*/
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

public class DateParser {

	public static Date getDate(String input) {
		Date date = null;
		Parser parser = new Parser();
		List<DateGroup> dateGroup= parser.parse(input);
		if (dateGroup.isEmpty()) { 
			System.out.println(date);
			return null; 
		}
		List<Date> dates = dateGroup.get(0).getDates();
		date = dates.get(0);
		System.out.println(date);
		return date;
	}

}
```
###### src\Parser\DeleteParser.java
``` java
* Parser for deleting a task
*/
import java.util.Date;
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandDelete;
import logic.commands.CommandInvalid;
import logic.commands.CommandType;
import logic.tasks.Deadline;

public class DeleteParser extends GeneralParser {
	
	public Command parse(String inputArgs){
		try{
		CommandType cmd = CommandType.DELETE;
		Command cmdDetails =null;
		String title = null;
		Date date = null;
		int inputNum = getInputNum(inputArgs);
		boolean checkSize = checkInputArgs(inputArgs,1);
		if(inputNum==-1||!checkSize){
			cmd=CommandType.INVALID;
			return cmdDetails = new CommandInvalid();
		}
		//String description = getDescription(inputTokens[1]);
		Deadline task = new Deadline(title,date);
		cmdDetails = new CommandDelete(inputNum);
		
		return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new  CommandInvalid();
		}
		
	}
}
```
###### src\Parser\EditParser.java
``` java
* Parser for editing a task
*/
import java.util.Date;
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandEdit;
import logic.commands.CommandInvalid;
import logic.commands.CommandType;
import logic.tasks.Deadline;

public class EditParser extends GeneralParser {
	
	protected Command parse(String inputArgs){
		try{
		Command cmdDetails=null;
		int inputNum = getInputNum(inputArgs);
		boolean checkSize = checkInputArgs(inputArgs,2);
		if(inputNum==-1||!checkSize){
			return cmdDetails = new  CommandInvalid();
		}
		Deadline task = getEditTask(inputArgs);
		if(task ==null){
			return new CommandInvalid();
		}
		//String description = getDescription(inputArgs);
		cmdDetails = new CommandEdit(inputNum,task);
		
		return cmdDetails;
		} catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new  CommandInvalid();
		}
		
	}

	private Deadline getEditTask(String inputArgs) {
		String title;
		Date date;
		int titleIndex;
		Deadline task;
		String temp = inputArgs.toLowerCase();
		int dateIndex = temp.indexOf("d:");
		if(dateIndex==-1){
			date=null;
			titleIndex = temp.indexOf("t:");
			if(titleIndex==-1){
				return null;
			}
			titleIndex+=2;
			title = getTitle(inputArgs.substring(titleIndex).trim());
			task = new Deadline(title,date);
		}
		else{
		date = getDate(inputArgs.substring(dateIndex));

		titleIndex = temp.indexOf("t:");
		if(titleIndex==-1){
			return null;
		}
		titleIndex+=2;
		title = getTitle(inputArgs.substring(titleIndex,dateIndex).trim());
		
		task = new Deadline(title,date);
		System.out.println(title);
		System.out.println(date);
		}
		return task;
	}

}
```
###### src\Parser\GeneralParser.java
``` java
* parser class with the basic methods
*/
import java.util.Date;

import logic.commands.Command;

public abstract class GeneralParser {
	
	private static final String REGEX_SPACE = "\\s";

	protected abstract Command parse(String inputArgs);
	
	
	protected String getTitle(String input){
		String title = newTitleParser.getTitle(input);
		return title;
	}
	
	protected Date getDate(String input){
		Date date = DateParser.getDate(input);
		return date;
	}

	protected int getInputNum(String inputArgs) {
		int num = InputNumParser.getInputNum(inputArgs);
		return num;
	}
	
	protected boolean checkInputArgs(String inputArgs, int size){
		String[] inputToken = inputArgs.split(REGEX_SPACE);
		if(inputToken.length<size){
			return false;
		}
		return true;
	}
	
	/*
	private static String getDescription(String[] inputTokens) {
		String description = "";
		for (int i = 0; i < inputTokens.length; i++) {
			if (inputTokens[i].charAt(0) == '/') {
				StringBuilder sb = new StringBuilder(inputTokens[i]);
				sb = sb.deleteCharAt(0);
				description = sb.toString();
				break;
			}
		}
		return description;
	}
*/
}
```
###### src\Parser\InputNumParser.java
``` java
* Parser for getting an input number
*/
public class InputNumParser {
	
	private static final String REGEX_SPACE = "\\s";
	
	public static int getInputNum(String inputArgs) {
		String[] inputTokens = inputArgs.split(REGEX_SPACE);
		String inputNum=inputTokens[0];
		int num;
		try{
			num=Integer.parseInt(inputNum);
		}
		catch(Exception e){
			num=-1;
		}
		if(num<1){
			num=-1;
		}
		return num;
	}
}
```
###### src\Parser\newTitleParser.java
``` java
* parser that obtains the title
*/
public class newTitleParser {
	private static final String START = "(?<=^|\\s)";
	private static final String END = "(?=\\s|$)";
	private static final String MISC_REGEX ="(by?|at?|on?|next?|this?|by next?|by this?)"+"\\s";
	private static final String MONTHNAME = "(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)";
	private static final String DATES = "(\\d?\\d)(?:st|rd|nd|th)?";
	private static final String YEAR = "(\\d{2}|\\d{4})";
	
	private static final String DATE_MONTH_REGEX = "(?<=\\s|^)" + DATES + "\\s" + MONTHNAME + "(?=\\s|$)";
	private static final String MONTH_DATE_REGEX = "(?<=\\s|^)" + MONTHNAME + "\\s" + DATES + "(?=\\s|$)";
	private static final String DATE_MONTH_YEAR_REGEX = "(?<=\\s|^)" + DATES + "\\s" + MONTHNAME + "?\\s?" + YEAR + "(?=\\s|$)";
	private static final String MONTH_DATE_YEAR_REGEX = "(?<=\\s|^)" + MONTHNAME + "\\s" + DATES + "?\\s?" + YEAR + "(?=\\s|$)";
	
	
	private static final String FIRST_DATE_REGEX = "("+ DATE_MONTH_YEAR_REGEX+ "|" + MONTH_DATE_YEAR_REGEX  +")";
	private static final String MISC_FIRST_DATE_REGEX = "("+ DATE_MONTH_YEAR_REGEX+ "|" + MONTH_DATE_YEAR_REGEX  +")";
	private static final String SECOND_DATE_REGEX="("+MISC_REGEX+ DATE_MONTH_REGEX+ "|" + MISC_REGEX+MONTH_DATE_REGEX  +")";
	private static final String MISC_SECOND_DATE_REGEX = "("+MISC_REGEX+ DATE_MONTH_YEAR_REGEX+ "|" +MISC_REGEX+ MONTH_DATE_YEAR_REGEX  +")";

	private static final String TMR_REGEX = "((tmr|tomorrow).*(?=\\s|$))";
	
	private static final String FIRST_DAY_REGEX="("+ MISC_REGEX+TMR_REGEX+ ")";
	private static final String DAYNAME = "(month?|mon(?:day)?|tue(?:day)?|wed(?:nesday)?|thur(?:sday)?|fri(?:day)?|sat(?:urday)?|sun(?:day)?)";
	private static final String SECOND_DAY_REGEX="("+ MISC_REGEX + DAYNAME+"|"+DAYNAME  +")";
	
	private static final String DAY = "(\\d?\\d)";
	private static final String MONTH = "(\\d?\\d)";
	private static final String DATE_SEP = "[-/]";
	private static final String NO_YEAR_FORMATTED_DATE_REGEX = START + DAY + "[-/]" + MONTH + END;
	private static final String FORMATTED_DATE_WITH_YEAR_REGEX = START + DAY + DATE_SEP + MONTH + DATE_SEP + YEAR + END;
	private static final String NUMBERED_DATE_REGEX = NO_YEAR_FORMATTED_DATE_REGEX + "|" + FORMATTED_DATE_WITH_YEAR_REGEX;
	private static final String MISC_NUMBERED_DATE_REGEX = MISC_REGEX+NO_YEAR_FORMATTED_DATE_REGEX + "|" + MISC_REGEX+FORMATTED_DATE_WITH_YEAR_REGEX;
	private static final String TWELVE_HR_REGEX = "([0-9]?[0-9])([.:][0-9][0-9])?\\s?(am|pm)?(\\s?(?:-|to|until|til|till)\\s?([0-9]?[0-9])([.:][0-9][0-9])?\\s?)?(am|pm)(?=\\s|$)";
	private static final String TWENTYFOUR_HR_REGEX = "(([0-9]?[0-9])[:]([0-9][0-9]))\\s?[?:h|H]?\\s?((?:-|to|until|til|till)?\\s?(([0-9]?[0-9])[:]([0-9][0-9])))?\\s?[?:h|H]?(?=\\s|$)";
		
	private static final String TIME_REGEX = "(" + TWELVE_HR_REGEX + "|" + TWENTYFOUR_HR_REGEX + ")";
	
	public static String getTitle(String inputArgs) {
		
		if (inputArgs == null) {
			return null;
		}
		inputArgs =inputArgs.replaceAll(FIRST_DATE_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(SECOND_DATE_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(MISC_FIRST_DATE_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(MISC_SECOND_DATE_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(FIRST_DAY_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(SECOND_DAY_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(MISC_NUMBERED_DATE_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(NUMBERED_DATE_REGEX,"");
		System.out.println(inputArgs);
		inputArgs =inputArgs.replaceAll(TIME_REGEX,"");
		System.out.println(inputArgs);
		return inputArgs.trim();
	}















}
```
###### src\Parser\SearchParser.java
``` java
* Parser for search command
*/
import java.util.Date;
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSearch;
import logic.commands.CommandType;
import logic.tasks.Deadline;

public class SearchParser extends GeneralParser {
	
	protected Command parse(String inputArgs){
		try{
		Command cmdDetails =null;
		String searchKey = getTitle(inputArgs);
		
		if(searchKey.equals("")||searchKey==null){
			return cmdDetails = new CommandInvalid();
		}
		//String description = getDescription(inputTokens[1]);
		cmdDetails = new CommandSearch(searchKey);
		
		return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}
		
	}
}
```
###### src\Parser\SetParser.java
``` java
* Parser for setting storage directory
*/
import java.util.logging.Level;

import logic.commands.Command;
import logic.commands.CommandInvalid;
import logic.commands.CommandSetLocation;
import logic.commands.CommandType;

public class SetParser extends GeneralParser{

	public Command parse(String inputArgs) {
		try{
			CommandType cmd = CommandType.SEARCH;
			Command cmdDetails =null;
			String stringPath = getTitle(inputArgs);
			if(stringPath.equals("")||stringPath==null){
				return cmdDetails = new CommandInvalid();
			}
			//String description = getDescription(inputTokens[1]);
			cmdDetails = new CommandSetLocation(stringPath);

			return cmdDetails;
		}
		catch(Exception e){
			e.printStackTrace();
			CommandParser.parserLogger.log(Level.WARNING, "processing error", e);
			return new CommandInvalid();
		}

	}
}
```
