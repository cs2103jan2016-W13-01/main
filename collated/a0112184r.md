# A0112184R
###### src\gui\Controller.java
``` java
	public static void main(String args[]) throws Exception{
		initialize();
	}
```
###### src\gui\Controller.java
``` java
	 * initialize the display window and all logic's components
	 */
	public static void initialize() throws Exception {
		DW = new DisplayWindow();
		DW.setVisible(true);
		TaskProcessor.initialize();
		displayTasks(TaskProcessor.getListToDisplay(), INCOMPLETE);
	}
```
###### src\logic\commands\Command.java
``` java
 * This interface represents the commands entered by the user
 */
public interface Command {
	
	public CommandType getType();
	
	public String execute();
	
	public String undo();
	
}
```
###### src\logic\commands\CommandAdd.java
``` java
 * Class CommandAdd: This class encapsulates the "add" commands from the user.
 */
public class CommandAdd implements Command {
	
	private static final String MESSAGE_TASK_ADDED = "Task added successfully: %s";
	private static final String MESSAGE_ADD_ERROR = "Error encountered when adding task. Please try again.";
	private static final String MESSAGE_UNDONE = "Action undone: add %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Failed to undo action: add %1$s";
	
	private final Task task;
	
	public CommandAdd(Task task) {
		assert task != null: "Attempt to create a null task";
		this.task = task;
	}
	
	public Task getTask() {
		return task;
	}
	
	public CommandType getType() {
		return CommandType.ADD;
	}

	public String execute() {
		LogicLogger.log(Level.INFO, "adding task: " + task.toString() + " to storage");
		try {
			StorageController.addNewTask(task);
			StorageController.setTabType("incomplete");
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "added successfully");
			return String.format(MESSAGE_TASK_ADDED, task.toMessage());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when adding to storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_ADD_ERROR;
		}
	}

	public String undo() {
		LogicLogger.log(Level.INFO, "deleting task: " + task.toString() + " from storage");
		try {
			StorageController.deleteTask(task);
			LogicLogger.log(Level.INFO, "undone successfully");
			return String.format(MESSAGE_UNDONE, task.toMessage());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return String.format(MESSAGE_UNDO_ERROR, task.toMessage());
		}
	}
	
}
```
###### src\logic\commands\CommandClear.java
``` java
 * This class contains details for "clear" commands
 */
public class CommandClear implements Command {
	
	private static final String MESSAGE_CLEARED = "All tasks removed";
	private static final String MESSAGE_UNDONE = "All tasks added back";
	private static final String MESSAGE_CLEAR_ERROR = "Error: fail to clear tasks";
	
	private ArrayList<Task> oldTaskList;
	
	public CommandType getType() {
		return CommandType.CLEAR;
	}
	
	public CommandClear() {
		oldTaskList = new ArrayList<Task>();
	}
	
	public String execute() {
		try {
			for (Task task: StorageController.getDisplayList()) {
				oldTaskList.add(task);
			}
			StorageController.clearDisplayedTasks();
			return MESSAGE_CLEARED;
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_CLEAR_ERROR;
		}
	}
	
	public String undo() {
		assert (oldTaskList != null) : "task list is null";
		String message = null;
		try {
			for (Task task: oldTaskList) {
				StorageController.addNewTask(task);
			}
			message = MESSAGE_UNDONE;
		} catch (IOException e) {
			message = e.toString();
		}
		return message;
	}
}
```
###### src\logic\commands\CommandDelete.java
``` java
 * This class encapsulates the "delete" commands from the user.
 */
public class CommandDelete implements Command {
	
	private static final String MESSAGE_DELETE_ERROR = "Error encountered when deleting task";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task number %s not found in task list";
	private static final String MESSAGE_TASK_DELETED = "Task deleted: %1$s";
	private static final String MESSAGE_UNDONE = "Task added back to task list: %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Failed to undo action: delete %1$s";
	
	private int taskNumberToDelete;
	private Task deletedTask;
	private String oldTab;
	
	public CommandDelete(int taskNumber) {
		taskNumberToDelete = taskNumber;
		deletedTask = null;
	}
	
	public CommandType getType() {
		return CommandType.DELETE;
	}
	
	public String execute() {
		try {
			deletedTask = StorageController.deleteByIndex(taskNumberToDelete-1);
			oldTab = StorageController.getTabType();
			LogicLogger.log(Level.INFO, "deleting task: " + deletedTask.toString() + " from storage");
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "deleted successfully");
			return String.format(MESSAGE_TASK_DELETED, deletedTask.toMessage());
		} catch (IndexOutOfBoundsException d) {
			LogicLogger.log(Level.WARNING, "Task not found");
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToDelete);
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_DELETE_ERROR;
		}
	}

	public String undo() {
		LogicLogger.log(Level.INFO, "adding task back: " + deletedTask.toString() + " to storage");
		try {
			StorageController.addNewTask(deletedTask);
			StorageController.setTabType(oldTab);
			LogicLogger.log(Level.INFO, "undone successfully");
			return String.format(MESSAGE_UNDONE, deletedTask.toMessage());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when adding from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return String.format(MESSAGE_UNDO_ERROR, deletedTask.toMessage());
		}
	}

}
```
###### src\logic\commands\CommandDisplay.java
``` java
 * This class contains details for the "display" commands
 */
public class CommandDisplay implements Command {
	
	private static final String MESSAGE_ALL_TASKS = "All tasks are displayed below:";
	private static final String MESSAGE_FLOAT_TASKS = "All undecided tasks are displayed below:";
	private static final String MESSAGE_DEADLINES = "All deadlines are displayed below:";
	private static final String MESSAGE_SESSIONS = "All sessions are displayed below:";
	private static final String MESSAGE_RECURRING = "All recurring tasks are displayed below:";
	private static final String MESSAGE_DISPLAY_DATE = "All tasks on %s are displayed below:";
	private static final String MESSAGE_INVALID = "Invalid criteria for display. Please try again";
	private static final String MESSAGE_INCOMPLETE = "All incomplete tasks are displayed below:";
	private static final String MESSAGE_COMPLETED = "All completed tasks are displayed below:";
	private static final String MESSAGE_UPCOMING = "All tasks of today and tomorrow are displayed below:";
	private String criteria;

	public CommandType getType() {
		return CommandType.DISPLAY;
	}
	
	public CommandDisplay(String word) {
		criteria = word;
	}
	
	public CommandDisplay() {
		criteria = "all";
	}
	
	public String execute() {
		if (criteria.equals("all")) {
			StorageController.setTabType("all");
			return MESSAGE_ALL_TASKS;
		} else if (criteria.equals("float")) {
			StorageController.setTabType("all");
			StorageController.displayFloatTasks();
			return MESSAGE_FLOAT_TASKS;
		} else if (criteria.equals("deadline")) {
			StorageController.setTabType("all");
			StorageController.displayDeadlines();
			return MESSAGE_DEADLINES;
		} else if (criteria.equals("session")) {
			StorageController.setTabType("all");
			StorageController.displaySessions();
			return MESSAGE_SESSIONS;
		} else if (criteria.equals("recurring")) {
			StorageController.setTabType("all");
			StorageController.displayRecurring();
			return MESSAGE_RECURRING;
		} else if (criteria.equals("undone")) {
			StorageController.setTabType("incomplete");
			return MESSAGE_INCOMPLETE;
		} else if (criteria.equals("done")) {
			StorageController.setTabType("completed");
			return MESSAGE_COMPLETED;
		} else if (criteria.equals("upcoming")) {
			StorageController.setTabType("upcoming");
			return MESSAGE_UPCOMING;
		} else {
			Calendar date = TaskUtil.stringToCalendar(criteria);
			if (date != null) {
				StorageController.setTabType("all");
				StorageController.displayTasksOnDate(date);
				return String.format(MESSAGE_DISPLAY_DATE, criteria);
			} else {
				return MESSAGE_INVALID;
			}
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandEdit.java
``` java
 * This class contains details for "edit" commands
 */
public class CommandEdit implements Command {
	
	private static final String MESSAGE_EDITED = "Task edited: %1$s";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task %1$s not found in task list";
	private static final String MESSAGE_EDIT_ERROR = "Error encountered when editing task";
	private static final String MESSAGE_UNDONE = "Task reverted: %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Error when undoing action: edit %1$s";
	
	private int taskNumberToEdit;
	private Task newTask;
	private Task oldTask;
	private String oldTab;
	
	public CommandEdit(int taskNumber,Task task) {
		taskNumberToEdit = taskNumber;
		newTask = task;
	}
	
	public CommandType getType() {
		return CommandType.EDIT;
	}
	
	public String execute() {
		LogicLogger.log(Level.INFO, "editing task: " + newTask.toString() + " in storage");
		try {
			oldTab = StorageController.getTabType();
			oldTask = StorageController.deleteByIndex(taskNumberToEdit-1);
			String titleString = newTask.getTitle();
			Calendar start = newTask.getStartDate();
			Calendar end = newTask.getEndDate();
			int period = newTask.getPeriod();
			
			if (titleString == null) {
				titleString = oldTask.getTitle();
			}
			if (start == null) {
				start = oldTask.getStartDate();
			}
			if (end == null) {
				end = oldTask.getEndDate();
			}
			if (period == 0) {
				period = oldTask.getPeriod();
			}
			newTask = TaskUtil.getInstance(titleString, start, end, period);
			
			StorageController.addNoSwitchTab(taskNumberToEdit-1, newTask);
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "edited successfully");
			return String.format(MESSAGE_EDITED, newTask.toMessage());
		} catch (IndexOutOfBoundsException d) {
			LogicLogger.log(Level.WARNING, "Task not found");
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToEdit);
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_EDIT_ERROR;
		}
	}
	
	public String undo() {
		try {
			StorageController.setTabType(oldTab);
			StorageController.deleteTask(newTask);
			StorageController.addNoSwitchTab(taskNumberToEdit-1, oldTask);
			return String.format(MESSAGE_UNDONE, oldTask.toMessage());
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_UNDO_ERROR, oldTask.toMessage());
		}
	}
}
```
###### src\logic\commands\CommandGetLocation.java
``` java
 * This class contains details for the get location command
 */
public class CommandGetLocation implements Command {
	
	private static final String MESSAGE_LOCATION = "Storage location is: %s";

	public CommandType getType() {
		return CommandType.GET;
	}
	
	public CommandGetLocation() {}
	
	public String execute() {
		String path = StorageController.getPath();
		System.out.println(path);
		return String.format(MESSAGE_LOCATION, path);
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandInvalid.java
``` java
 * This class signifies invalid commands
 */
public class CommandInvalid implements Command {
	
	private static final String MESSAGE_INVALID_COMMAND = "Invalid command. Please try again.";
	
	public CommandType getType() {
		return CommandType.INVALID;
	}
	
	public CommandInvalid() { }
	
	public String execute() {
		return MESSAGE_INVALID_COMMAND;
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandLoad.java
``` java
 * This class contains details for the "load from location" commands
 */
public class CommandLoad implements Command {
	
	private static final String MESSAGE_LOADED = "Data loaded from location: %s";
	private static final String MESSAGE_UNDONE = "Storage location set back to: %s";
	private static final String MESSAGE_UNDO_ERROR = "Sorry, failed to undo action: load %s";
	private static final String MESSAGE_LOAD_ERROR = "Sorry, failed to load data at location: %s";
	private String newPath;
	private String oldPath;

	public CommandType getType() {
		return CommandType.LOAD;
	}
	
	public CommandLoad(String path) {
		newPath = path;
	}
	
	public String execute() {
		try {
			oldPath = StorageController.getPath();
			StorageController.load(newPath);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_LOADED, newPath);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_LOAD_ERROR, newPath);
		}
	}
	
	public String undo() {
		try {
			StorageController.load(oldPath);
			return String.format(MESSAGE_UNDONE, oldPath);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_UNDO_ERROR, newPath);
		}
	}
}
```
###### src\logic\commands\CommandMark.java
``` java
 * This class contains details for the mark as done commands
 */
public class CommandMark implements Command {
	
	private static final String MESSAGE_TASK_MARKED = "Task completed: %s";
	private static final String MESSAGE_MARK_ERROR = "Error: failed to mark task as done";
	private static final String MESSAGE_TASK_DONE = "Task is already done";
	private static final String MESSAGE_TASK_UNMARKED = "Task is unmarked: %s";
	private static final String MESSAGE_UNMARK_ERROR = "Error: failed to unmark task";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task number %s not found in task list";
	
	private int taskNumber;
	private Task task;
	
	public CommandMark(int inputNum) {
		taskNumber = inputNum;
	}
	
	public CommandType getType() {
		return CommandType.MARK;
	}
	
	public String execute() {
		try {
			task = StorageController.getIndex(taskNumber-1);
			if (task.isDone()) {
				return MESSAGE_TASK_DONE;
			}
			task.setDone(true);
			StorageController.markDoneByIndex(taskNumber-1);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_TASK_MARKED, task.toMessage());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_MARK_ERROR;
		} catch (IndexOutOfBoundsException e) {
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumber);
		}
	}
	
	public String undo() {
		try {
			assert (task != null): "Task is null";
			assert (task.isDone()): "Task is somehow not done";
			task.setDone(false);
			StorageController.unmarkDone(task);
			return String.format(MESSAGE_TASK_UNMARKED, task.toMessage());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_UNMARK_ERROR;
		}
	}
}
```
###### src\logic\commands\CommandRedo.java
``` java
 *
 */
public class CommandRedo implements Command {
	
	private static final String MESSAGE_NO_COMMAND = "No undone commands";

	public CommandType getType() {
		return CommandType.REDO;
	}
	
	public CommandRedo() {}
	
	public String execute() {
		if (!UndoneCommands.isEmpty()) {
			Command lastUndoneCommand = UndoneCommands.getLatestCommand();
			LogicLogger.log(Level.INFO, "Undoing action");
			return lastUndoneCommand.execute();
		} else {
			LogicLogger.log(Level.INFO, "No action to undo");
			return MESSAGE_NO_COMMAND;
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandSearch.java
``` java
 * This class contains details for "search" commands
 */
public class CommandSearch implements Command {
	
	private static final String MESSAGE_SEARCH_RESULT = "Search results for %1$s:";
	
	private String keyword;
	
	public CommandType getType() {
		return CommandType.SEARCH;
	}
	
	public CommandSearch(String word) {
		keyword = word;
	}
	
	public String execute() {
		
		Predicate<Task> searchPredicate = new Predicate<Task>() {
			public boolean test(Task task) {
				String titleString = task.getTitle().toLowerCase();
				String[] keys;
				if (keyword.startsWith("\"") && keyword.endsWith("\"")) {
					keys = new String[]{ keyword };
				} else {
					keys = keyword.toLowerCase().split("\\s+");
				}
				boolean result = false;
				for (String word: keys) {
					if (titleString.contains(word)) {
						result = true;
					}
				}
				return result;
			}
		};
		
		StorageController.searchTask(searchPredicate);
		return String.format(MESSAGE_SEARCH_RESULT, keyword);
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandSetLocation.java
``` java
 * This class contains details for the "set location" commands
 */
import java.io.IOException;

import logic.ExecutedCommands;
import storage.StorageController;

public class CommandSetLocation implements Command {
	
	private static final String MESSAGE_LOCATION_SET = "storage location set to: %1$s";
	private static final String MESSAGE_UNDONE = "storage location reverted to: %1$s";
	private static final String MESSAGE_SET_ERROR = "Failed to set storage location to: %1$s";
	
	private String newPathName;
	private String oldPathName;
	
	public CommandType getType() {
		return CommandType.SET;
	}
	
	public CommandSetLocation(String pathName) {
		newPathName = pathName;
	}
	
	public String execute() {
		try {
			oldPathName = StorageController.getPath();
			StorageController.setPath(newPathName);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_LOCATION_SET, newPathName);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_SET_ERROR, newPathName);
		}
	}
	
	public String undo() {
		try {
			StorageController.setPath(oldPathName);
			return String.format(MESSAGE_UNDONE, oldPathName);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_SET_ERROR, oldPathName);
		}
	}
}
```
###### src\logic\commands\CommandType.java
``` java
 * enum CommandType: contains possible types for user commands.
 */
package logic.commands;

public enum CommandType {
	ADD, DELETE, CLEAR, DISPLAY, INVALID, UNDO, MARK, UNMARK, EDIT, SEARCH, SET, HELP, REDO, GET, DELETE_RECUR, EDIT_RECUR, LOAD;
}
```
###### src\logic\commands\CommandUndo.java
``` java
 * This class contains details for "undo" commands
 */
public class CommandUndo implements Command {
	
	private static final String MESSAGE_COMMAND_UNDONE = "Command undone successfully";
	private static final String MESSAGE_NO_COMMAND = "No command to undo";

	public CommandType getType() {
		return CommandType.UNDO;
	}
	
	public CommandUndo() {}
	
	public String execute() {
		if (!ExecutedCommands.isEmpty()) {
			Command lastExecutedCommand = ExecutedCommands.getLatestCommand();
			LogicLogger.log(Level.INFO, "Undoing action");
			UndoneCommands.addCommand(lastExecutedCommand);
			return lastExecutedCommand.undo();
		} else {
			LogicLogger.log(Level.INFO, "No action to undo");
			return MESSAGE_NO_COMMAND;
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandUnmark.java
``` java
 * This class contains details for the unmark commands
 */
public class CommandUnmark implements Command {
	
	private static final String MESSAGE_TASK_MARKED = "Task marked as done again: %s";
	private static final String MESSAGE_MARK_ERROR = "Error: failed to mark task as done";
	private static final String MESSAGE_TASK_NOT_DONE = "Task is already not done";
	private static final String MESSAGE_TASK_UNMARKED = "Task is unmarked: %s";
	private static final String MESSAGE_UNMARK_ERROR = "Error: failed to unmark task";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task number %s not found in task list";

	private int taskNumber;
	private Task task;
	
	public CommandUnmark(int inputNum) {
		taskNumber = inputNum;
	}
	
	public CommandType getType() {
		return CommandType.UNMARK;
	}
	
	public String execute() {
		try {
			task = StorageController.getIndex(taskNumber-1);
			if (!task.isDone()) {
				return MESSAGE_TASK_NOT_DONE;
			}
			StorageController.unmarkDoneByIndex(taskNumber-1);
			task.setDone(false);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_TASK_UNMARKED, task.toMessage());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_UNMARK_ERROR;
		} catch (IndexOutOfBoundsException e) {
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumber);
		}
	}
	
	public String undo() {
		try {
			assert (task != null): "Task is null";
			assert (!task.isDone()): "Task is somehow done";
			StorageController.markDone(task);
			task.setDone(true);
			return String.format(MESSAGE_TASK_MARKED, task.toMessage());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_MARK_ERROR;
		}
	}
}
```
###### src\logic\ExecutedCommands.java
``` java
 * This stack contains the executed commands
 * Each time an undo is executed, the top of the stack is popped out and undone
 */
public class ExecutedCommands {
	
	public static Stack<Command> executedCommands;
	
	public static Command getLatestCommand() {
		return executedCommands.pop();
	}
	
	public static boolean addCommand(Command command) {
		return executedCommands.add(command);
	}
	
	public static boolean isEmpty() {
		return executedCommands.isEmpty();
	}
	
	public static int getSize() {
		return executedCommands.size();
	}
	
	public static void initialize() {
		executedCommands = new Stack<Command>();
	}
}
```
###### src\logic\LogicLogger.java
``` java
 * Logger for Logic
 */
import java.util.logging.Level;
import java.util.logging.Logger;

public class LogicLogger {
	
	public static Logger logicLogger;
	
	public static void initialize() {
		logicLogger = Logger.getLogger("LogicLogger");
	}
	
	public static void log(Level level, String message) {
		logicLogger.log(level, message);
	}
}
```
###### src\logic\Priority.java
``` java
 * enum type containing the possible values for a task's priority
 */

package logic;

public enum Priority {
	URGENT, HIGH, MEDIUM, LOW, NULL;
}
```
###### src\logic\Response.java
``` java
 * This class contains all the information the Logic send to the UI for displaying
 */
public class Response {
	
	private String message;
	private ArrayList<String> taskList;
	private String type;
        
	
	public Response(String msg, String tabType, ArrayList<String> list) {
		message = msg;
		taskList = list;
		type = tabType;
	}
	
	public Response(String msg, ArrayList<String> list) {
		message = msg;
		taskList = list;
		type = "incomplete";
	}
	
	public Response(String msg) {
		message = msg;
	}
	
	public Response(ArrayList<String> list) {
		taskList = list;
	}
	
	public String getMessage() {
		return message;
	}
	
	public ArrayList<String> getTaskList() {
		return taskList;
	}
	
	public boolean equals(Response res) {
		return (getMessage().equals(res.getMessage()) && getTaskList().equals(res.getTaskList()));
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(getMessage());
		if (taskList == null) {
			sb.append("\r\n");
			sb.append("null");
		} else {
			for (String str: taskList) {
				sb.append("\r\n");
				sb.append(str);
			}
		}
		return sb.toString();
	}


	public String getType() {
		return type;
	}
	
	public void setType(String newType) {
		type = newType;
	}
}
```
###### src\logic\TaskProcessor.java
``` java
 * Class TaskProcessor
 * This class contains methods to execute all the user commands and issue commands to other components.
 * Key methods so far:
 *     - executeCommand(Command): execute the Command object by calling Command.execute()
 *     - executeInput(String): execute the input by parsing it and call executeCommand
 *     - initialize: initialize the StorageController and all the components
 */
public class TaskProcessor {
	
	/*
	private static final String MESSAGE_DISPLAY_ERROR = "Error encountered when displaying tasks. Please try again";
	private static final String MESSAGE_CLEAR_ERROR = "Error encountered when clearing all tasks. Please try again";
	private static final String MESSAGE_SORT_ERROR = "Error encountered when sorting tasks. Please try again.";
	*/

	private static ArrayList<String> listToDisplay;

	
	public static ArrayList<String> getListToDisplay() {
		loadIntoDisplayList(StorageController.getDisplayList());
		return listToDisplay;
	}
	
	public static Response executeInput(String input) {
		LogicLogger.log(Level.INFO, "Executing input: " + input);
		Command command = CommandParser.parseInput(input);
		return executeCommand(command);
	}

	public static Response executeCommand(Command command) {
		String message = command.execute();
		if (command instanceof CommandHelp) {
			ArrayList<String> helpContent = ((CommandHelp) command).getHelpContent();
			return new Response(message, "help", helpContent);
		}
		if (command instanceof CommandInvalid) {
			return new Response(command.execute(), "no change", null);
		}
		ArrayList<String> taskList = getListToDisplay();
		return new Response(message, StorageController.getTabType(), taskList);
	}
	
	public static void initialize() {
		listToDisplay = new ArrayList<String>();
		ExecutedCommands.initialize();
		UndoneCommands.initialize();
		LogicLogger.initialize();
		try {
			LogicLogger.log(Level.INFO, "Initializing StorageController");
			StorageController.initialize();
			loadIntoDisplayList(StorageController.getDisplayList());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when initializing StorageController");
			e.printStackTrace();
			System.exit(0);
		}
	}
	
	private static void loadIntoDisplayList(ArrayList<Task> taskList) {
		LogicLogger.log(Level.INFO, "Loading list to display from StorageController");
		listToDisplay.clear();
		for (Task task: taskList) {
			assert task != null : "Some task in the task list is null";
			listToDisplay.add(task.toString());
		}
	}
}
```
###### src\logic\tasks\RecurringTask.java
``` java
 * This class contains details for recurring tasks
 */
public class RecurringTask extends Task {
	
	private static final String DAILY = "every day";
	private static final String WEEKLY = "every week";
	private static final String MONTHLY = "every month";
	private static final String YEARLY = "every year";
	private static final String PERIODLY = "every %s day";
	private static final int EVERY_DAY = 1;
	private static final int EVERY_YEAR = -2;
	private static final int EVERY_MONTH = -1;
	private static final int EVERY_WEEK = 7;
	private static final Comparator<Calendar> DAY_COMP = new Comparator<Calendar>() {
		public int compare(Calendar date1, Calendar date2) {
			return DateUtils.truncatedCompareTo(date1, date2, Calendar.DATE);
		}
	};
	
	private int period;
	private SortedSet<Task> doneInstances;
	private SortedSet<Task> deletedInstances;

	public RecurringTask(String title, Calendar start, Calendar end, int time) {
		super(title, start, (start == null && end == null)? floatingTimeToDeadline(time): end);
		period = time;
		doneInstances = new TreeSet<Task>();
		deletedInstances = new TreeSet<Task>();
	}

	private static Calendar floatingTimeToDeadline(int time) {
		Calendar end = Calendar.getInstance();
		if (time > 0) {
			end = getEndOfNDays(time);
		} else if (time % 2 == 1) {
			end = getEndOfNMonths((1-time)/2);
		} else {
			end = getEndOfNYears(-time/2);
		}
		return end;
	}

	private static Calendar getEndOfNDays(int numDays) {
		Calendar result = Calendar.getInstance();
		result.set(Calendar.HOUR_OF_DAY, 23);
		result.set(Calendar.MINUTE, 59);
		result.add(Calendar.DATE, numDays);
		return result;
	}
	
	private static Calendar getEndOfNMonths(int numMonths) {
		Calendar result = Calendar.getInstance();
		result.set(Calendar.HOUR_OF_DAY, 23);
		result.set(Calendar.MINUTE, 59);
		result.add(Calendar.MONTH, numMonths);
		return result;
	}
	
	private static Calendar getEndOfNYears(int numYears) {
		Calendar result = Calendar.getInstance();
		result.set(Calendar.HOUR_OF_DAY, 23);
		result.set(Calendar.MINUTE, 59);
		result.add(Calendar.YEAR, numYears);
		return result;
	}

	// constructors
	public RecurringTask(String title, Calendar start, Calendar end) {
		this(title, start, end, EVERY_DAY);
	}
	
	public RecurringTask(String title, Calendar start, int time) {
		this(title, start, null, time);
	}
	
	public RecurringTask(String title, int time) {
		this(title, Calendar.getInstance(), time);
	}
	
	public RecurringTask(String title) {
		this(title, Calendar.getInstance(), EVERY_DAY);
	}
	// end
	
	// methods for period
	@Override
	public int getPeriod() {
		return period;
	}
	
	@Override
	public String getPeriodString() {
		if (period == EVERY_YEAR) {
			return YEARLY;
		} else if (period == EVERY_MONTH) {
			return MONTHLY;
		} else if (period == EVERY_WEEK) {
			return WEEKLY;
		} else if (period == EVERY_DAY) {
			return DAILY;
		} else {
			return String.format(PERIODLY, period);
		}
	}
	
	public void setPeriod(int newPeriod) {
		period = newPeriod;
	}
	// end
	
	private int daysUntil(Calendar date) {
		return TaskUtil.daysBetween(getMainDate() , date);
	}
	
	private boolean isSameDayOfMonth(Calendar date) {
		return getMainDate().get(Calendar.DAY_OF_MONTH) == date.get(Calendar.DAY_OF_MONTH);
	}
	
	private boolean isSameDayOfYear(Calendar date) {
		return (getMainDate().get(Calendar.MONTH) == date.get(Calendar.MONTH))
				&& (getMainDate().get(Calendar.DAY_OF_MONTH) == date.get(Calendar.DAY_OF_MONTH));
	}
	
	/*
	private Calendar getClosestDate(Calendar start, Calendar des, int step) {
		if (start == null) {
			return null;
		}
		Calendar count = Calendar.getInstance();
		count.setTime(start.getTime());
		while (DAY_COMP.compare(count, des) < 0) {
			count.add(Calendar.DATE, step);
		}
		return count;
	} */
	
	private Calendar[] getClosestDates(Calendar[] starts, Calendar des, int step) {
		Calendar start = null;
		Calendar[] results = new Calendar[starts.length];
		for (int i=starts.length-1; i>=0; i--) {
			Calendar date = starts[i];
			results[i] = TaskUtil.cloneDate(date);
			if (date != null) {
				start = results[i];
			}
		}

		if (start == null) {
			return results;
		}
		while ((DAY_COMP.compare(start, des) < 0) || (!willOccur(start))) {
			for (Calendar date: results) {
				TaskUtil.addDate(date, Calendar.DATE, step);
			}
		}
		return results;
	}
	
	/*
	public boolean willOccurWithinNDays(Calendar date, int n) {
		Calendar closest = getClosestDate(getStartDate(), date, period);
		return (TaskUtil.daysBetween(date, closest) <= n);
	} */
	
	@Override
	public boolean willOccur(Calendar date) {
		if (date.before(getStartDate()) || isException(date)) {
			return false;
		}
		if (period == EVERY_YEAR) {
			return isSameDayOfYear(date);
		}
		if (period == EVERY_MONTH) {
			return isSameDayOfMonth(date);
		}
		int dayDistance = daysUntil(date);
		return (dayDistance % period) == 0;
	}
	
	public Task generate(Calendar date) {
		Calendar[] dates = {getStartDate(), getEndDate()};
		Calendar[] results = getClosestDates(dates, date, period);
		Task instance =  TaskUtil.getInstance(getTitle(), results[0], results[1]);
		instance.setParent(this);
		return instance;
	}
	public Task generateNearestInstance() {
		return generate(getMainDate());
	}
	
	// methods for done instances
	public SortedSet<Task> getDoneInstances() {
		return doneInstances;
	}
	
	public boolean addDoneInstance(Task instance) {
		return doneInstances.add(instance);
	}

	public boolean isDoneInstance(Task instance) {
		return doneInstances.contains(instance);
	}
	
	public boolean removeDoneInstance(Task instance) {
		return doneInstances.remove(instance);
	}
	// end
	
	// methods for deleted instances
	public SortedSet<Task> getDeletedInstances() {
		return deletedInstances;
	}
	
	public boolean addDeletedInstance(Task instance) {
		return deletedInstances.add(instance);
	}
	
	public boolean isDeletedInstance(Task instance) {
		return deletedInstances.contains(instance);
	}
	
	public boolean reviveDeletedInstance(Task instance) {
		return deletedInstances.remove(instance);
	}
	// end
	
	public boolean isException(Task instance) {
		return isDoneInstance(instance) || isDeletedInstance(instance);
	}
	
	public boolean isException(Calendar date) {
		boolean result = false;
		for (Task instance: doneInstances) {
			if (DateUtils.isSameDay(instance.getMainDate(), date)) {
				result = true;
				break;
			}
		}
		if (result) {
			return result;
		}
		for (Task instance: deletedInstances) {
			if (DateUtils.isSameDay(instance.getMainDate(), date)) {
				result = true;
				break;
			}
		}
		return result;
	}
	
	// equals
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof RecurringTask) {
			return equalTitles(getTitle(), ((RecurringTask) obj).getTitle())
					&& equalDates(getStartDate(), ((RecurringTask) obj).getStartDate())
					&& equalDates(getEndDate(), ((RecurringTask) obj).getEndDate())
					&& (getPeriod() == ((RecurringTask) obj).getPeriod());
		}
		return false;
	}
}
```
###### src\logic\tasks\Task.java
``` java
 * This class encloses the general task types
 */
public class Task implements Cloneable, Comparable<Task> {
	
	private static final String FIELD_SEPARATOR = "; ";
	private static final String NULL_DATE = "-";
	private static final String STATUS_UNDONE = "incomplete";
	private static final String STATUS_DONE = "completed";
	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm dd MMM");
	private String title;
	private boolean done;
	private Calendar start;
	private Calendar end;
	private RecurringTask parent;

	public Calendar getStartDate() {
		return start;
	}
	
	public Calendar getEndDate() {
		return end;
	}
	
	public Task(String title, Calendar startDate, Calendar endDate) {
		this.title = title;
		start = startDate;
		end = endDate;
		done = false;
		parent = null;
	}
	
	public Calendar getMainDate() {
		if (start != null) {
			return start;
		} else {
			return end;
		}
	}
	
	public String getTitle() {
		return title;
	}
	
	public String setTitle(String newTitle) {
		title = newTitle;
		return newTitle;
	}
	
	public boolean isDone() {
		return done;
	}
	
	public void setDone(boolean value) {
		done = value;
	}
	
	public int getPeriod() {
		return 0;
	}
	
	public RecurringTask getParent() {
		return parent;
	}
	
	public void setParent(RecurringTask recurTask) {
		parent = recurTask;
	}
	
	public String toMessage() {
		String titleString, timeString, periodString;
		titleString = getTitleString();
		periodString = getPeriodString().equals(NULL_DATE)? "": getPeriodString();
		if (start != null && end != null) {
			timeString = "from " + getStartString() + " to " + getEndString();
		} else if (start != null) {
			timeString = "at " + getStartString();
		} else if (end != null) {
			timeString = "by " + getEndString();
		} else {
			timeString = "";
		}
		return titleString + " " + timeString + " " + periodString;
	}
	
	@Override
	public String toString() {
		String titleString, startString, endString, isDoneString, periodString;
		titleString = getTitleString();
		startString = getStartString();
		endString = getEndString();
		isDoneString = getStatusString();
		periodString = getPeriodString();
		return isDoneString + FIELD_SEPARATOR + titleString + FIELD_SEPARATOR
				+ startString + FIELD_SEPARATOR + endString + FIELD_SEPARATOR + periodString;
	}

	public String getPeriodString() {
		RecurringTask parent = getParent();
		if (parent != null) {
			return parent.getPeriodString();
		} else {
			return "Once";
		}
	}

	public String getStatusString() {
		return (done == true)? STATUS_DONE: STATUS_UNDONE;
	}

	public String getEndString() {
		return (end == null)? NULL_DATE: DATE_FORMAT.format(end.getTime());
	}

	public String getStartString() {
		return (start == null)? NULL_DATE: DATE_FORMAT.format(start.getTime());
	}

	public String getTitleString() {
		return (title  == null)? "unspecified": title;
	}
	
	public boolean willOccur(Calendar date) {
		if (start == null && end == null) {
			return false;
		} else if (start == null) {
			return DateUtils.isSameDay(end, date);
		} else if (end == null) {
			return DateUtils.isSameDay(start, date);
		}
		return (DateUtils.truncatedCompareTo(start, date, Calendar.DATE) <= 0)
				&& (DateUtils.truncatedCompareTo(end, date, Calendar.DATE) >= 0);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Task) {
			return equalTitles(getTitle(), ((Task) obj).getTitle())
					&& equalDates(getStartDate(), ((Task) obj).getStartDate())
					&& equalDates(getEndDate(), ((Task) obj).getEndDate())
					&& (isDone() == ((Task) obj).isDone());
		}
		return false;
	}
	
	protected static boolean equalDates(Calendar date1, Calendar date2) {
		if (date1 == null) {
			return date2 == null;
		} else {
			return DateUtils.truncatedEquals(date1, date2, Calendar.MINUTE);
		}
	}
	
	protected static boolean equalTitles(String title1, String title2) {
		if (title1 == null) {
			return title2 == null;
		} else {
			return title1.trim().equalsIgnoreCase(title2.trim());
		}
	}
	
	@Override
	public int compareTo(Task task) {
		Calendar date = task.getMainDate();
		Calendar thisDate = getMainDate();
		int dateComp = compareDate(thisDate, date);
		if (dateComp != 0) {
			return dateComp;
		} else {
			return compareTitle(title, task.getTitle());
		}
	}
	
	private int compareTitle(String title1, String title2) {
		if (title1 == null && title2 == null) {
			return 0;
		} else if (title1 == null) {
			return -1;
		} else if (title2 == null) {
			return 1;
		} else {
			return title1.trim().compareToIgnoreCase(title2.trim());
		}
	}

	private int compareDate(Calendar date1, Calendar date2) {
		if (date1 == null && date2 == null) {
			return 0;
		} else if (date1 == null) {
			return 1;
		} else if (date2 == null) {
			return -1;
		} else {
			return DateUtils.truncatedCompareTo(date1, date2, Calendar.MINUTE);
		}
	}
}
```
###### src\logic\tasks\TaskUtil.java
``` java
 * This class contains the getInstance() method to generate a Task object
 * and the comparator for tasks
 */
public class TaskUtil {
	
	private static final String LINE_SEPARATOR = ":";
	private static final String NULL_TIME = "-";
	private static final String FIELD_SEPARATOR = ";";
	private static final SimpleDateFormat STORAGE_FORMAT = new SimpleDateFormat("HH:mm yyyyMMdd", Locale.ENGLISH);
	private static final SimpleDateFormat DISPLAY_FORMAT = new SimpleDateFormat("dd MMM HH:mm", Locale.ENGLISH);

	public static class TaskComparator implements Comparator<Task> {
		public int compare(Task task1, Task task2) {
			return task1.compareTo(task2);
		}
	}
	
	public static Task getInstance(String title, Calendar startDate, Calendar endDate, int period) {
		if (period == 0) {
			return new Task(title, startDate, endDate);
		} else {
			return new RecurringTask(title, startDate, endDate, period);
		}
	}
	
	public static Task getInstance(String title, Calendar endDate, int period) {
		return getInstance(title, null, endDate, period);
	}
	
	public static Task getInstance(String title, int period) {
		return getInstance(title, null, period);
	}
	
	public static Task getInstance(String title) {
		return getInstance(title, 0);
	}
	
	public static Task getInstance(String title, Calendar startDate, Calendar endDate) {
		return new Task(title, startDate, endDate);
	}
	
	public static Task getInstance(String title, Calendar endDate) {
		return new Task(title, null, endDate);
	}
	
```
###### src\logic\TextUI.java
``` java
 * This class is used to test the program when the GUI was in progress
 */
package logic;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Scanner;

import logic.commands.Command;
import parser.CommandParser;

public class TextUI {
	
	private static Scanner sc;
	
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		initialize();
		while (sc.hasNextLine()) {
			String input = sc.nextLine();
			Response response = executeInput(input);
			displayResponse(response, System.out);
		}
		sc.close();
	}
	
	public static void mainFileToFile(File inputFile, File outputFile) throws FileNotFoundException {
		sc = new Scanner(inputFile);
		PrintStream pr = new PrintStream(outputFile);
		initialize();
		while (sc.hasNextLine()) {
			String input = sc.nextLine();
			Response response = executeInput(input);
			displayResponse(response, pr);
		}
		sc.close();
		pr.close();
	}

	private static Response executeInput(String input) {
		Command command = CommandParser.parseInput(input);
		Response response = TaskProcessor.executeCommand(command);
		return response;
	}
	
	public static void displayResponse(Response response, PrintStream printer) {
		if (response != null) {
			displayMessage(response.getMessage(), printer);
			displayTaskList(response.getTaskList(), printer);
		}
	}
	
	public static void displayMessage(String message, PrintStream printer) {
		printer.println(message);
	}
	
	public static void displayTaskList(ArrayList<String> taskList, PrintStream printer) {
		if (taskList != null) {
			if (!taskList.isEmpty()) {
				int lineNum = 0;
				for (String task: taskList) {
					lineNum++;
					printer.print(lineNum + ". ");
					printer.println(task);
				}
			} else {
				printer.println("No tasks to show");
			}
		} else {
			printer.println("Task list not loaded");
		}
	}
	
	public static void getInput() {
		String input = sc.nextLine();
		InputQueue.addInput(input);
	}
	
	public static void initialize() {
		ExecutedCommands.initialize();
		TaskProcessor.initialize();
	}
}
```
###### src\logic\UndoneCommands.java
``` java
 *
 */
public class UndoneCommands {
	
	public static Stack<Command> undoneCommands;
	
	public static Command getLatestCommand() {
		return undoneCommands.pop();
	}
	
	public static boolean addCommand(Command command) {
		return undoneCommands.add(command);
	}
	
	public static boolean isEmpty() {
		return undoneCommands.isEmpty();
	}
	
	public static int getSize() {
		return undoneCommands.size();
	}
	
	public static void initialize() {
		undoneCommands = new Stack<Command>();
	}
}
```
###### src\storage\GrandTaskList.java
``` java
 *
 */
public class GrandTaskList {
	
	private static TaskList<Task> normalTaskList;
	private static TaskList<RecurringTask> recurringTaskList;
	private static TaskList<Task> doneTaskList;
	private static TaskList<Task> recurringInstanceList;
	private static TaskList<RecurringTask> doneRecurringList;
	
	// initializer
	public static void initialize() throws IOException {
		normalTaskList = new TaskList<Task>("normal");
		recurringTaskList = new TaskList<RecurringTask>("recurring");
		doneTaskList = new TaskList<Task>("done");
		doneRecurringList = new TaskList<RecurringTask>("done recurring");
		recurringInstanceList = new TaskList<Task>("instances");
		Database.load();
		initRecurringInstances();
		initDoneList();
	}
	
	public static void initRecurringInstances() {
		for (RecurringTask recur: recurringTaskList) {
			recurringInstanceList.add(recur.generateNearestInstance());
		}
	}
	
	public static void initDoneList() {
		for (RecurringTask recurTask: recurringTaskList) {
			addDoneRecurringInstance(recurTask);
		}
	}
	
	public static void addDoneRecurringInstance(RecurringTask recurTask) {
		for (Task instance: recurTask.getDoneInstances()) {
			instance.setDone(true);
			doneTaskList.add(instance);
		}
	}
	
	// get different types of list
	public static TaskList<Task> getNormalList() {
		return normalTaskList;
	}
	
	public static TaskList<Task> getRecurringInstanceList() {
		return recurringInstanceList;
	}
	
	public static TaskList<RecurringTask> getRecurringList() {
		return recurringTaskList;
	}
	
	public static TaskList<Task> getDoneList() {
		return doneTaskList;
	}
	
	public static TaskList<RecurringTask> getDoneRecurringList() {
		return doneRecurringList;
	}
	
	public static TaskList<Task> getTotalList() {
		TaskList<Task> results = new TaskList<Task>();
		normalTaskList.merge(results);
		doneTaskList.merge(results);
		recurringInstanceList.merge(results);
		return results;
	}
	
	public static TaskList<Task> getNonRecurringList() {
		TaskList<Task> results = new TaskList<Task>();
		normalTaskList.merge(results);
		doneTaskList.merge(results);
		return results;
	}
	
	public static TaskList<Task> getUndoneList() {
		TaskList<Task> results = new TaskList<Task>();
		normalTaskList.merge(results);
		recurringInstanceList.merge(results);
		return results;
	}	
	
	public static TaskList<Task> getUpcomingList() {
		return getUpComingList(2);
	}
	
	public static TaskList<Task> getUpComingList(int numDays) {
		Calendar date = Calendar.getInstance();
		TaskList<Task> result = new TaskList<Task>();
		for (int i=0; i<numDays; i++) {
			getTasksOnDate(date).merge(result);
			date.add(Calendar.DATE, 1);
		}
		return result;
	}
	
	public static TaskList<Task> search(Predicate<Task> predicate) {
		TaskList<Task> results = new TaskList<Task>();
		normalTaskList.merge(results, predicate);
		recurringInstanceList.merge(results, predicate);
		doneTaskList.merge(results, predicate);
		return results;
	}
	
	public static TaskList<Task> getTasksOnDate(Calendar date) {
		TaskList<Task> results = new TaskList<Task>();
		for (Task task: normalTaskList) {
			if (task.willOccur(date)) {
				results.add(task);
			}
		}
		for (RecurringTask task: recurringTaskList) {
			if (task.willOccur(date)) {
				results.add(task.generate(date));
			}
		}
		return results;
	}
	
	public static TaskList<Task> getListByName(String name) {
		if (name.equals("all")) {
			return getTotalList();
		} else if (name.equals("upcoming")) {
			return getUpcomingList();
		} else if (name.equals("completed")) {
			return getDoneList();
		} else if (name.equals("incomplete")) {
			return getUndoneList();
		} else {
			return new TaskList<Task>();
		}
	}
	
	// operations on tasks
```
###### src\storage\GrandTaskList.java
``` java
	/* mark a task as done and move it to the done task list
	 * 
	 */
	public static boolean markDone(Task task) throws IOException {
		boolean result;
		task.setDone(true);
		if (task instanceof RecurringTask) {
			result = recurringTaskList.delete((RecurringTask) task);
			doneRecurringList.add((RecurringTask) task);
			Database.saveRecurring();
			Database.saveDoneRecurring();
		} else if (task.getParent() == null) {
			result = deleteTask(task);
			doneTaskList.add(task);
			Database.saveNormal();
			Database.saveDone();
		} else {
			RecurringTask parent = task.getParent();
			parent.addDoneInstance(task);
			result = doneTaskList.add(task);
			if (recurringInstanceList.delete(task)) {
				recurringInstanceList.add(parent.generateNearestInstance());
			}
			Database.saveRecurring();
		}
		return result;
	}
	
	/* unmark a task and move it back to its old task list
	 * 
	 */
	public static boolean unmarkDone(Task task) throws IOException {
		boolean result;
		task.setDone(false);
		if (task instanceof RecurringTask) {
			result = doneRecurringList.delete((RecurringTask) task);
			recurringTaskList.add((RecurringTask) task);
			Database.saveRecurring();
			Database.saveDoneRecurring();
		} else if (task.getParent() == null) {
			result = doneTaskList.delete(task);
			addNewTask(task);
			Database.saveDone();
		} else {
			RecurringTask parent = task.getParent();
			recurringInstanceList.delete(parent.generateNearestInstance());
			parent.removeDoneInstance(task);
			result = doneTaskList.delete(task);
			recurringInstanceList.add(parent.generateNearestInstance());
			Database.saveRecurring();
		}
		return result;
	}
	
	public static void clearIncomplete() {
		normalTaskList.clear();
	}
	
	public static void clearAll() throws IOException {
		recurringTaskList.clear();
		normalTaskList.clear();
		doneTaskList.clear();
		doneRecurringList.clear();
		recurringInstanceList.clear();
	}
}
```
###### src\storage\StorageController.java
``` java
 * This class controls the adding, deleting, saving, loading, searching in the storage
 */
public class StorageController {
	
	private static ArrayList<Task> displayList;
	private static String tabType;
	
	public static ArrayList<Task> getDisplayList() {
		return displayList;
	}
	
	public static String getTabType() {
		return tabType;
	}
	
	public static void setTabType(String newTab) {
		if (newTab.equals("all")) {
			displayAllTasks();
			tabType = newTab;
		} else if (newTab.equals("incomplete")) {
			displayUndoneList();
			tabType = newTab;
		} else if (newTab.equals("completed")) {
			displayDoneList();
			tabType = newTab;
		} else if (newTab.equals("upcoming")) {
			displayUpcomingList();
			tabType = newTab;
		}
	}
	
	// initializer
	public static void initialize() throws IOException {
		displayList = new ArrayList<Task>();
		Database.initialize();
		GrandTaskList.initialize();
		loadDisplayList();
		setTabType("incomplete");
	}
	
	public static void loadDisplayList() {
		for (Task task: GrandTaskList.getUndoneList()) {
			displayList.add(task);
		}
	}
	
	public static Task getIndex(int index) {
		return displayList.get(index);
	}
	
	// operations on the task list
	// delete
	public static Task deleteByIndex(int index) throws IOException {
		Task task = displayList.get(index);
		deleteTask(task);
		return task;
	}
	
	public static boolean deleteTask(Task task) throws IOException {
		boolean result;
		if (task instanceof RecurringTask) {
			result = deleteRecurringTask((RecurringTask) task);
		} else {
			result = GrandTaskList.deleteTask(task);
			displayList.remove(task);
		}
		return result;
	}
	
	public static boolean deleteRecurringTask(RecurringTask recurTask) throws IOException {
		boolean result = GrandTaskList.deleteTask(recurTask);
		ArrayList<Task> listToDelete = new ArrayList<Task>();
		for (Task instance: displayList) {
			if (instance.getParent() == recurTask && !instance.isDone()) {
					listToDelete.add(instance);
			}
		}
		for (Task instance: listToDelete) {
			displayList.remove(instance);
		}
		return result;
	}
	
	// add
	public static boolean addNewTask(Task task) throws IOException {
		boolean result = GrandTaskList.addNewTask(task);
		return result;
	}
	
	public static boolean addNoSwitchTab(int index, Task task) throws IOException {
		boolean result = GrandTaskList.addNewTask(task);
		displayList.add(index, task);
		return result;
	}
	
	// mark and unmark
	public static Task markDoneByIndex(int index) throws IOException {
		Task task = displayList.get(index);
		markDone(task);
		return task;
	}

	
	public static boolean markDone(Task task) throws IOException {
		boolean result = GrandTaskList.markDone(task);
		return result;
	}
	
	public static boolean markDoneRecurring(RecurringTask recurTask) throws IOException {
		boolean result = GrandTaskList.markDone(recurTask);
		ArrayList<Task> markedList = new ArrayList<Task>();
		for (Task instance: displayList) {
			if (instance.getParent() == recurTask && !instance.isDone()) {
				markedList.add(instance);
			}
		}
		for (Task instance: markedList) {
			displayList.remove(instance);
		}
		return result;
	}
	
	public static Task unmarkDoneByIndex(int index) throws IOException {
		Task task = displayList.get(index);
		unmarkDone(task);
		return task;
	}
	
	public static boolean unmarkDone(Task task) throws IOException {
		boolean result = GrandTaskList.unmarkDone(task);
		return result;
	}
	
	public static boolean unmarkDoneRecurring(RecurringTask recurTask) throws IOException {
		boolean result = GrandTaskList.unmarkDone(recurTask);
		for (Task instance: displayList) {
			if (instance.getParent() == recurTask && !recurTask.isDoneInstance(instance)) {
				unmarkDone(instance);
			}
		}
		return result;
	}
	
	// methods to get different sub lists
	public static void displayAllTasks() {
		displayList = GrandTaskList.getTotalList().toArrayList();
	}
	
	public static void displayFloatTasks() {
		Predicate<Task> pred = new Predicate<Task>() {
			public boolean test(Task task) {
				return (task.getStartDate() == null && task.getEndDate() == null);
			}
		};
		searchTask(pred);
	}
	
	public static void displayDeadlines() {
		Predicate<Task> pred = new Predicate<Task>() {
			public boolean test(Task task) {
				return (task.getStartDate() == null && task.getEndDate() != null)
						|| (task.getStartDate() != null && task.getEndDate() == null);
			}
		};
		searchTask(pred);
	}
	
	public static void displaySessions() {
		Predicate<Task> pred = new Predicate<Task>() {
			public boolean test(Task task) {
				return (task.getStartDate() != null && task.getEndDate() != null);
			}
		};
		searchTask(pred);
	}
	
	public static void displayRecurring() {
		displayList.clear();
		displayList = GrandTaskList.getRecurringInstanceList().toArrayList();
	}
	
	public static void displayTasksOnDate(Calendar date) {
		displayList.clear();
		displayList = GrandTaskList.getTasksOnDate(date).toArrayList();
	}
	
	public static void displayUndoneList() {
		displayList.clear();
		displayList = GrandTaskList.getUndoneList().toArrayList();
	}
	
	public static void displayUpcomingList() {
		displayList.clear();
		displayList = GrandTaskList.getUpcomingList().toArrayList();
	}
	
	public static void displayDoneList() {
		displayList.clear();
		displayList = GrandTaskList.getDoneList().toArrayList();
	}
	
	public static void searchTask(Predicate<Task> predicate) {
		ArrayList<Task> searchResults = new ArrayList<Task>();
		for (Task task: displayList) {
			if (predicate.test(task)) {
				searchResults.add(task);
			}
		}
		displayList = searchResults;
	}
	
	// methods to clear lists
	public static void clearDisplayedTasks() throws IOException {
		for (Task task: displayList) {
			GrandTaskList.deleteTask(task);
		}
		displayList.clear();
	}
	
	public static void clearAllTasks() throws IOException {
		GrandTaskList.clearAll();
		displayList.clear();
	}
	
	// set and get storage path
	public static void setPath(String pathName) throws IOException {
		Database.setPath(pathName);
		Database.save();
	}
	
	public static String getPath() {
		return Database.getPath();
	}
	
	public static ArrayList<Task> getTimelineList() {
		ArrayList<Task> result = new ArrayList<Task>();
		for (Task task: GrandTaskList.getNonRecurringList()) {
			Calendar date = task.getStartDate();
			Calendar nextOneMonth = Calendar.getInstance();
			nextOneMonth.add(Calendar.DATE, 30);
			if (date != null
				&& DateUtils.truncatedCompareTo(date,
						nextOneMonth,
						Calendar.DATE) < 0) {
				result.add(task);
			}
		}
		return result;
	}

	
	public static void load(String newPath) throws IOException {
		GrandTaskList.clearAll();
		displayList.clear();
		Database.setPath(newPath);
		Database.load();
	}
}
```
###### src\storage\StorageLogger.java
``` java
 * Logger for Logic
 */
import java.util.logging.Level;
import java.util.logging.Logger;

public class StorageLogger {
	
	public static Logger storageLogger;
	
	public static void initialize() {
		storageLogger = Logger.getLogger("StorageLogger");
	}
	
	public static void log(Level level, String message) {
		storageLogger.log(level, message);
	}
}
```
###### src\storage\TaskList.java
``` java
 * This class contains the lists of specific types of tasks
 */
public class TaskList<T extends Task> implements Iterable<T> {
	
	private SortedSet<T> taskList;
	private String name;
	
	public TaskList() {
		taskList = new TreeSet<T>();
		name = null;
	}
	
	public TaskList(String nameString) {
		taskList = new TreeSet<T>();
		name = nameString;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String nameString) {
		name = nameString;
	}
	
	public Iterator<T> iterator() {
		return taskList.iterator();
	}
	
	public SortedSet<T> getInternalList() {
		return taskList;
	}
	
	public boolean contains(Task task) {
		return taskList.contains(task);
	}
	public boolean add(T task) {
		return taskList.add(task);
	}
	
	public boolean addAll(TaskList<T> addedList) {
		return taskList.addAll(addedList.getInternalList());
	}
	
	public boolean delete(T task) {
		return taskList.remove(task);
	}
	
	public int size() {
		return taskList.size();
	}
	
	public void clear() {
		taskList.clear();
	}
	
	public void merge(TaskList<Task> results, Predicate<Task> predicate) {
		for (Task task: taskList) {
			if (predicate.test(task)) {
				results.add(task);
			}
		}
	}
	
	public void merge(TaskList<Task> results) {
		Predicate<Task> predicate = new Predicate<Task>() {
			public boolean test(Task task) {
				return true;
			}
		};
		merge(results, predicate);
	}
	
	public ArrayList<Task> toArrayList() {
		ArrayList<Task> result = new ArrayList<Task>();
		for (Task task: taskList) {
			result.add(task);
		}
		return result;
	}

}
```
