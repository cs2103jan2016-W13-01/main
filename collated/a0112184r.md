# A0112184R
###### src\gui\Controller.java
``` java
    public static void main(String args[]){
        initialize();
    }
```
###### src\gui\Controller.java
``` java
     * initialize the display window and all logic's components
     */
	public static void initialize() {
    	DW = new DisplayWindow();
        DW.setVisible(true);
		TaskProcessor.initialize();
		displayTasks(TaskProcessor.getListToDisplay(), Storage.getFloatBeginOnIndexList());
	}
```
###### src\logic\commands\Command.java
``` java
 * This interface represents the commands entered by the user
 */
public interface Command {
	
	public CommandType getType();
	
	public String execute();
	
	public String undo();
	
}
```
###### src\logic\commands\CommandAdd.java
``` java
 * Class CommandAdd: This class encapsulates the "add" commands from the user.
 */
public class CommandAdd implements Command {
	
	private static final String MESSAGE_TASK_ADDED = "Task added successfully";
	private static final String MESSAGE_ADD_ERROR = "Error encountered when adding task. Please try again.";
	private static final String MESSAGE_UNDONE = "Action undone: add %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Failed to undo action: add %1$s";
	
	private final Deadline task;
	
	public CommandAdd(Deadline task) {
		assert task != null: "Attempt to create a null task";
		this.task = task;
	}
	
	public Deadline getTask() {
		return task;
	}
	
	public CommandType getType() {
		return CommandType.ADD;
	}

	public String execute() {
		LogicLogger.log(Level.INFO, "adding task: " + task.toString() + " to storage");
		try {
			Storage.addNewTask(task);
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "added successfully");
			return MESSAGE_TASK_ADDED;
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when adding to storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_ADD_ERROR;
		}
	}

	public String undo() {
		LogicLogger.log(Level.INFO, "deleting task: " + task.toString() + " from storage");
		try {
			Storage.deleteTask(Storage.getTaskList().size() - 1);
			LogicLogger.log(Level.INFO, "undone successfully");
			return String.format(MESSAGE_UNDONE, task.toString());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return String.format(MESSAGE_UNDO_ERROR, task.toString());
		}
	}
	
}
```
###### src\logic\commands\CommandClear.java
``` java
 * This class contains details for "clear" commands
 */
public class CommandClear implements Command {
	
	private static final String MESSAGE_CLEARED = "All tasks removed";
	private static final String MESSAGE_UNDONE = "All tasks added back";
	
	private ArrayList<Deadline> oldTaskList;
	
	public CommandType getType() {
		return CommandType.CLEAR;
	}
	
	public CommandClear() {
		
	}
	
	public String execute() {
		oldTaskList = new ArrayList<Deadline>();
		for (Deadline task: Storage.getTaskList()) {
			oldTaskList.add(task.clone());
		}
		Storage.clearAllTasks();
		return MESSAGE_CLEARED;
	}
	
	public String undo() {
		assert (oldTaskList != null) : "task list is null";
		String message = null;
		try {
			for (Deadline task: oldTaskList) {
				Storage.addNewTask(task);
			}
			message = MESSAGE_UNDONE;
		} catch (IOException e) {
			message = e.toString();
		}
		return message;
	}
}
```
###### src\logic\commands\CommandDelete.java
``` java
 * This class encapsulates the "delete" commands from the user.
 */
public class CommandDelete implements Command {
	
	private static final String MESSAGE_DELETE_ERROR = "Error encountered when deleting task";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task not found in task list: %1$s";
	private static final String MESSAGE_TASK_DELETED = "Task deleted: %1$s";
	private static final String MESSAGE_UNDONE = "Task added back to task list: %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Failed to undo action: delete %1$s";
	
	private int taskNumberToDelete;
	private int deletedTaskIndex;
	private Deadline deletedTask;
	
	public CommandDelete(int taskNumber) {
		taskNumberToDelete = taskNumber;
		deletedTask = null;
	}
	
	public CommandType getType() {
		return CommandType.DELETE;
	}
	
	public String execute() {
		try {
			deletedTaskIndex = Storage.getIndexList().get(taskNumberToDelete-1);
			deletedTask = Storage.deleteTask(deletedTaskIndex);
			if (deletedTask != null) {
				LogicLogger.log(Level.INFO, "deleting task: " + deletedTask.toString() + " from storage");
				ExecutedCommands.addCommand(this);
				LogicLogger.log(Level.INFO, "deleted successfully");
				return String.format(MESSAGE_TASK_DELETED, deletedTask.toString());
			} else {
				LogicLogger.log(Level.WARNING, "Task not found");
				return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToDelete);
			}
		} catch (IndexOutOfBoundsException d) {
			LogicLogger.log(Level.WARNING, "Task not found");
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToDelete);
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_DELETE_ERROR;
		}
	}

	public String undo() {
		LogicLogger.log(Level.INFO, "adding task: " + deletedTask.toString() + " to storage");
		try {
			Storage.addNewTask(deletedTask, deletedTaskIndex);
			LogicLogger.log(Level.INFO, "undone successfully");
			return String.format(MESSAGE_UNDONE, deletedTask.toString());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when adding from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return String.format(MESSAGE_UNDO_ERROR, deletedTask.toString());
		}
	}

}
```
###### src\logic\commands\CommandDisplay.java
``` java
 * This class contains details for the "display" commands
 */
public class CommandDisplay implements Command {
	
	private static final String MESSAGE_ALL_TASKS = "All tasks are displayed below:";

	public CommandType getType() {
		return CommandType.DISPLAY;
	}
	
	public CommandDisplay() {
	}
	
	public String execute() {
		
		Storage.displayAllTasks();
		return MESSAGE_ALL_TASKS;
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandEdit.java
``` java
 * This class contains details for "edit" commands
 */
public class CommandEdit implements Command {
	
	private static final String MESSAGE_EDITED = "Task edited: %1$s";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task %1$s not found in task list";
	private static final String MESSAGE_EDIT_ERROR = "Error encountered when editing task";
	private static final String MESSAGE_UNDONE = "Task reverted: %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Error when undoing action: edit %1$s";
	
	private int taskNumberToEdit;
	private int editedTaskIndex;
	private Deadline editedTask;
	private Deadline oldTask;
	
	public CommandEdit(int taskNumber,Deadline task) {
		taskNumberToEdit = taskNumber;
		editedTask = task;
	}
	
	public CommandType getType() {
		return CommandType.EDIT;
	}
	
	public String execute() {
		LogicLogger.log(Level.INFO, "editing task: " + editedTask.toString() + " in storage");
		try {
			editedTaskIndex = Storage.getIndexList().get(taskNumberToEdit-1);
			oldTask = Storage.deleteTask(editedTaskIndex);
			if (oldTask != null) {
				Storage.addNewTask(editedTask, editedTaskIndex);
				ExecutedCommands.addCommand(this);
				LogicLogger.log(Level.INFO, "edited successfully");
				return String.format(MESSAGE_EDITED, editedTask.toString());
			} else {
				LogicLogger.log(Level.WARNING, "Task not found");
				return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToEdit);
			}
		} catch (IndexOutOfBoundsException d) {
			LogicLogger.log(Level.WARNING, "Task not found");
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToEdit);
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_EDIT_ERROR;
		}
	}
	
	public String undo() {
		try {
			assert (Storage.deleteTask(editedTaskIndex) != null): "Cannot find edited task";
			Storage.addNewTask(oldTask, editedTaskIndex);
			return String.format(MESSAGE_UNDONE, oldTask.toString());
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_UNDO_ERROR, oldTask.toString());
		}
	}
}
```
###### src\logic\commands\CommandInvalid.java
``` java
 * This class signifies invalid commands
 */
public class CommandInvalid implements Command {
	
	private static final String MESSAGE_INVALID_COMMAND = "Invalid command. Please try again.";
	
	public CommandType getType() {
		return CommandType.INVALID;
	}
	
	public CommandInvalid() { }
	
	public String execute() {
		return MESSAGE_INVALID_COMMAND;
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandSearch.java
``` java
 * This class contains details for "search" commands
 */
public class CommandSearch implements Command {
	
	private static final String MESSAGE_SEARCH_ERROR = "Error encountered when searching for keyword. Please try again.";
	private static final String MESSAGE_NO_MATCH = "No match found.";
	private static final String MESSAGE_SEARCH_RESULT = "Search results for %1$s:";
	
	private String keyword;
	
	public CommandType getType() {
		return CommandType.SEARCH;
	}
	
	public CommandSearch(String word) {
		keyword = word;
	}
	
	public String execute() {
		
		Predicate<Deadline> searchPredicate = new Predicate<Deadline>() {
			public boolean test(Deadline task) {
				String titleString = task.getTitle().toLowerCase();
				return titleString.contains(keyword.toLowerCase());
			}
		};
		
		Storage.searchTask(searchPredicate);
		return String.format(MESSAGE_SEARCH_RESULT, keyword);
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandSetLocation.java
``` java
 * This class contains details for the "set location" commands
 */
import java.io.IOException;

import logic.ExecutedCommands;
import storage.Storage;

public class CommandSetLocation implements Command {
	
	private static final String MESSAGE_LOCATION_SET = "storage location set to: %1$s";
	private static final String MESSAGE_UNDONE = "storage location reverted to: %1$s";
	private static final String MESSAGE_SET_ERROR = "Failed to set storage location to: %1$s";
	
	private String newPathName;
	private String oldPathName;
	
	public CommandType getType() {
		return CommandType.SET;
	}
	
	public CommandSetLocation(String pathName) {
		newPathName = pathName;
	}
	
	public String execute() {
		try {
			oldPathName = Storage.getPath();
			Storage.setPath(newPathName);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_LOCATION_SET, newPathName);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_SET_ERROR, newPathName);
		}
	}
	
	public String undo() {
		try {
			Storage.setPath(oldPathName);
			return String.format(MESSAGE_UNDONE, oldPathName);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_SET_ERROR, oldPathName);
		}
	}
}
```
###### src\logic\commands\CommandType.java
``` java
 * enum CommandType: contains possible types for user commands.
 */
package logic.commands;

public enum CommandType {
	ADD, DELETE, CLEAR, DISPLAY, INVALID, UNDO, MARK, UNMARK, EDIT, SEARCH, SET, HELP;
}
```
###### src\logic\commands\CommandUndo.java
``` java
 * This class contains details for "undo" commands
 */
public class CommandUndo implements Command {
	
	private static final String MESSAGE_COMMAND_UNDONE = "Command undone successfully";
	private static final String MESSAGE_NO_COMMAND = "No command to undo";

	public CommandType getType() {
		return CommandType.UNDO;
	}
	
	public CommandUndo() {}
	
	public String execute() {
		if (!ExecutedCommands.isEmpty()) {
			Command lastExecutedCommand = ExecutedCommands.getLatestCommand();
			LogicLogger.log(Level.INFO, "Undoing action");
			lastExecutedCommand.undo();
			return MESSAGE_COMMAND_UNDONE;
		} else {
			LogicLogger.log(Level.INFO, "No action to undo");
			return MESSAGE_NO_COMMAND;
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\ExecutedCommands.java
``` java
 * This stack contains the executed commands
 * Each time an undo is executed, the top of the stack is popped out and undone
 */
public class ExecutedCommands {
	
	public static Stack<Command> executedCommands;
	
	public static Command getLatestCommand() {
		return executedCommands.pop();
	}
	
	public static boolean addCommand(Command command) {
		return executedCommands.add(command);
	}
	
	public static boolean isEmpty() {
		return executedCommands.isEmpty();
	}
	
	public static int getSize() {
		return executedCommands.size();
	}
	
	public static void initialize() {
		executedCommands = new Stack<Command>();
	}
}
```
###### src\logic\LogicLogger.java
``` java
 * Logger for Logic
 */
import java.util.logging.Level;
import java.util.logging.Logger;

public class LogicLogger {
	
	public static Logger logicLogger;
	
	public static void initialize() {
		logicLogger = Logger.getLogger("LogicLogger");
	}
	
	public static void log(Level level, String message) {
		logicLogger.log(level, message);
	}
}
```
###### src\logic\Priority.java
``` java
 * enum type containing the possible values for a task's priority
 */

package logic;

public enum Priority {
	URGENT, HIGH, MEDIUM, LOW, NULL;
}
```
###### src\logic\Response.java
``` java
 * This class contains all the information the Logic send to the UI for displaying
 */
public class Response {
	
	private String message;
	private ArrayList<String> taskList;
        
        public Response() {
	
	}
	
	
	public Response(String msg, ArrayList<String> list, int index) {
		message = msg;
		taskList = list;
	}
	
	public Response(String msg) {
		message = msg;
	}
	
	public Response(ArrayList<String> list) {
		taskList = list;
	}
	
	public String getMessage() {
		return message;
	}
	
	public ArrayList<String> getTaskList() {
		return taskList;
	}
	
	public boolean equals(Response res) {
		return (getMessage().equals(res.getMessage()) && getTaskList().equals(res.getTaskList()));
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(getMessage());
		if (taskList == null) {
			sb.append("\r\n");
			sb.append("null");
		} else {
			for (String str: taskList) {
				sb.append("\r\n");
				sb.append(str);
			}
		}
		return sb.toString();
	}
}
```
###### src\logic\TaskProcessor.java
``` java
 * Class TaskProcessor
 * This class contains methods to execute all the user commands and issue commands to other components.
 * Key methods so far:
 *     - executeCommand(Command): execute the Command object by calling Command.execute()
 *     - executeInput(String): execute the input by parsing it and call executeCommand
 *     - initialize: initialize the storage and all the components
 */
public class TaskProcessor {
	
	/*
	private static final String MESSAGE_DISPLAY_ERROR = "Error encountered when displaying tasks. Please try again";
	private static final String MESSAGE_CLEAR_ERROR = "Error encountered when clearing all tasks. Please try again";
	private static final String MESSAGE_SORT_ERROR = "Error encountered when sorting tasks. Please try again.";
	*/

	private static ArrayList<String> listToDisplay;
	
	public static void main(String[] args) {
		while (true) {
			getAndExecuteCommand();
		}
	}
	
	public static ArrayList<String> getListToDisplay() {
		loadIntoDisplayList(Storage.getTaskList(), Storage.getIndexList());
		return listToDisplay;
	}
	
	public static void getAndExecuteCommand() {
		Command command = CommandQueue.getCommand();
		if (command != null) {
			executeCommand(command);
		}
	}
	
	public static Response executeInput(String input) {
		LogicLogger.log(Level.INFO, "Executing input: " + input);
		Command command = CommandParser.parseInput(input);
		return executeCommand(command);
	}

	public static Response executeCommand(Command command) {
		String message = command.execute();
		ArrayList<String> taskList = getListToDisplay();
		return new Response(message, taskList, Storage.getFloatBeginOnIndexList());
	}
	
	public static void initialize() {
		listToDisplay = new ArrayList<String>();
		ExecutedCommands.initialize();
		LogicLogger.initialize();
		try {
			LogicLogger.log(Level.INFO, "Initializing storage");
			Storage.initialize();
			loadIntoDisplayList(Storage.getTaskList(), Storage.getIndexList());
		} catch (ClassNotFoundException e) {
			LogicLogger.log(Level.SEVERE, "Error when initializing storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when initializing storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
		}
	}
	
	private static void loadIntoDisplayList(ArrayList<Deadline> taskList, ArrayList<Integer> indexList) {
		LogicLogger.log(Level.INFO, "Loading list to display from storage");
		listToDisplay.clear();
		for (int i: indexList) {
			Deadline task = taskList.get(i);
			assert task != null : "Some task in the task list is null";
			listToDisplay.add(task.toString());
		}
	}
}
```
###### src\logic\tasks\Deadline.java
``` java
 * This class stores all the information in a task.
 * Fields:
 *     - title: details about the task
 *     - date: date for the task to be done or deadline
 *     - priority: the task's priority
 */
public class Deadline extends Task {

	private Date date;
	private Priority priority;
	
	@Override
	public TaskType getType() {
		return TaskType.NORMAL;
	}
	
	@Override
	public Date getMainDate() {
		return date;
	}
	
	public Date getDate() {
		return date;
	}
	
	public String getDateString() {
		if (date == null) {
			return "";
		} else {
			return date.toString();
		}
	}
	
	public Priority getPriority() {
		return priority;
	}
	
	public void setDate(Date newDate) {
		date = newDate;
	}
	
	public void setPriority(Priority newPrio) {
		priority = newPrio;
	}
	
	public Deadline(String title, Date date, Priority priority) {
		super(title);
		this.date = date;
		this.priority = priority;
	}
	
	public Deadline(String title, Date date) {
		this(title, date, Priority.NULL);
	}
	
	public Deadline(String title) {
		this(title, new Date(), Priority.NULL);
	}
	
	public String toString() {
		String result = getTitle() + " " + getDateString();
		return result;
	}
	
	public boolean equals(Deadline otherTask) {
		return (getTitle().equals(otherTask.getTitle()) && getDate().equals(otherTask.getDate()));
	}
	
	public Deadline clone() {
		Deadline copiedTask = new Deadline(title, date);
		return copiedTask;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Deadline) {
			return (((Deadline) obj).getType() == this.getType())
					&& ((Deadline) obj).getTitle().equalsIgnoreCase(this.getTitle())
					&& ((Deadline) obj).getDate().equals(this.getDate());
		}
		return false;
	}
}
```
###### src\logic\tasks\RecurringTask.java
``` java
 * This class contains details for recurring tasks
 */
public class RecurringTask extends Task {
	
	private static final int EVERY_DAY = 1;
	private Date startDate;
	private Date endDate;
	private int period;
	
	@Override
	public TaskType getType() {
		return TaskType.RECUR;
	}
	
	@Override
	public Date getMainDate() {
		return null;
	}
	
	public RecurringTask(String title, Date start, Date end, int time) {
		super(title);
		startDate = start;
		endDate = end;
		period = time;
	}
	
	public RecurringTask(String title, Date start, Date end) {
		this(title, start, end, EVERY_DAY);
	}
	
	public RecurringTask(String title, Date start, int time) {
		this(title, start, null, time);
	}
	
	public RecurringTask(String title, int time) {
		this(title, new Date(), time);
	}
	
	public RecurringTask(String title) {
		this(title, new Date(), EVERY_DAY);
	}
	
	public Date getStartDate() {
		return startDate;
	}
	
	public Date getEndDate() {
		return endDate;
	}
	
	public int getPeriod() {
		return period;
	}
	
	public void setStartDate(Date newDate) {
		startDate = newDate;
	}
	
	public void setPeriod(int newPeriod) {
		period = newPeriod;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof RecurringTask) {
			return (((RecurringTask) obj).getType() == this.getType())
					&& ((RecurringTask) obj).getTitle().equalsIgnoreCase(this.getTitle())
					&& ((RecurringTask) obj).getStartDate().equals(this.getStartDate())
					&& ((Session) obj).getEndDate().equals(this.getEndDate())
					&& (((RecurringTask) obj).getPeriod() == this.getPeriod());
		}
		return false;
	}
}
```
###### src\logic\tasks\Session.java
``` java
 * This class contains details for sessions with start and end time
 */
public class Session extends Task {
	
	private Date start;
	private Date end;
	
	@Override
	public TaskType getType() {
		return TaskType.SESSION;
	}
	
	@Override
	public Date getMainDate() {
		return start;
	}
	
	public Session(String title, Date startDate, Date endDate) {
		super(title);
		start = startDate;
		end = endDate;
	}
	
	public Date getStartDate() {
		return start;
	}
	
	public Date getEndDate() {
		return end;
	}
	
	public void setStartDate(Date newStart) {
		start = newStart;
	}
	
	public void setEndDate(Date newEnd) {
		end = newEnd;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Session) {
			return (((Session) obj).getType() == this.getType())
					&& ((Session) obj).getTitle().equalsIgnoreCase(this.getTitle())
					&& ((Session) obj).getStartDate().equals(this.getStartDate())
					&& ((Session) obj).getEndDate().equals(this.getEndDate());
		}
		return false;
	}
}
```
###### src\logic\tasks\Task.java
``` java
 * This class encloses the general task types
 */
public class Task implements Cloneable {
	
	protected String title;
	protected boolean done;
	
	public TaskType getType() {
		return TaskType.FLOAT;
	}
	
	public Date getMainDate() {
		return null;
	}
	
	public Task(String title) {
		this.title = title;
		done = false;
	}
	
	public String getTitle() {
		if (title == null) return "unspecified title";
		return title;
	}
	
	public String setTitle(String newTitle) {
		title = newTitle;
		return newTitle;
	}
	
	public boolean isDone() {
		return done;
	}
	
	public boolean markDone() {
		done = true;
		return done;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Task) {
			return (((Task) obj).getType() == this.getType())
					&& ((Task) obj).getTitle().equalsIgnoreCase(this.getTitle());
		}
		return false;
	}
}
```
###### src\logic\tasks\TaskType.java
``` java
 * This enum contains the possible task types
 */
public enum TaskType {
	FLOAT, NORMAL, SESSION, RECUR;
}
```
###### src\logic\tasks\TaskUtil.java
``` java
 * This class contains the getInstance() method to generate a Task object
 * and the comparator for tasks
 */
public class TaskUtil {
	
	public static class TaskComparator implements Comparator<Task> {
		public int compare(Task task1, Task task2) {
			Date date1 = task1.getMainDate();
			Date date2 = task2.getMainDate();
			if (date1 == null && date2 == null) {
				return task1.getTitle().compareToIgnoreCase(task2.getTitle());
			} else if (date1 == null) {
				return 1;
			} else if (date2 == null) {
				return -1;
			} else {
				return date1.compareTo(date2);
			}
		}
	}
	
	public Task getInstance(String title, Date startDate, Date endDate, int recurringPeriod) {
		if (startDate == null && endDate == null) {
			return new Task(title);
		} else if (recurringPeriod > 0) {
			return new RecurringTask(title, startDate, endDate, recurringPeriod);
		} else if (endDate == null){
			return new Deadline(title, startDate);
		} else {
			return new Session(title, startDate, endDate);
		}
	}
	
	public Task getInstance(String title, Date startDate, Date endDate) {
		return getInstance(title, startDate, endDate, 0);
	}
	
	public Task getInstance(String title, Date startDate, int recurringPeriod) {
		return getInstance(title, startDate, null, recurringPeriod);
	}
	
	public Task getInstance(String title, Date startDate) {
		return getInstance(title, startDate, null, 0);
	}
}
```
###### src\storage\GrandTaskList.java
``` java
 *
 */
public class GrandTaskList {
	
	private static TaskList<Task> floatTaskList;
	private static TaskList<Deadline> deadlineList;
	private static TaskList<Session> sessionList;
	private static TaskList<RecurringTask> recurringTaskList;
	
	public static void initialize() {
		floatTaskList = new TaskList<Task>();
		deadlineList = new TaskList<Deadline>();
		sessionList = new TaskList<Session>();
		recurringTaskList = new TaskList<RecurringTask>();
	}
	
	public static TaskList<Task> getFloatList() {
		return floatTaskList;
	}
	
	public static TaskList<Deadline> getDeadlineList() {
		return deadlineList;
	}
	
	public static TaskList<Session> getSessionList() {
		return sessionList;
	}
	
	public static TaskList<RecurringTask> getRecurringList() {
		return recurringTaskList;
	}
	
	public static boolean addNewTask(Task task) {
		if (task instanceof Deadline) {
			return deadlineList.add((Deadline) task);
		} else if (task instanceof Session) {
			return sessionList.add((Session) task);
		} else if (task instanceof RecurringTask) {
			return recurringTaskList.add((RecurringTask) task);
		} else {
			return floatTaskList.add(task);
		}
	}
	
	public static boolean deleteTask(Task task) {
		if (task instanceof Deadline) {
			return deadlineList.delete((Deadline) task);
		} else if (task instanceof Session) {
			return sessionList.delete((Session) task);
		} else if (task instanceof RecurringTask) {
			return recurringTaskList.delete((RecurringTask) task);
		} else {
			return floatTaskList.delete(task);
		}
	}
	
	public static TaskList<Task> search(Predicate<Task> predicate) {
		TaskList<Task> results = new TaskList<Task>();
		deadlineList.search(results, predicate);
		sessionList.search(results, predicate);
		recurringTaskList.search(results, predicate);
		floatTaskList.search(results, predicate);
		return results;
	}
}
```
###### src\storage\TaskList.java
``` java
 * This class contains the lists of specific types of tasks
 */
public class TaskList<T extends Task> implements Iterable<T> {
	
	private SortedSet<T> taskList;
	
	public TaskList() {
		taskList = new TreeSet<T>(new TaskUtil.TaskComparator());
	}
	
	public Iterator<T> iterator() {
		return taskList.iterator();
	}
	
	public SortedSet<T> getInternalList() {
		return taskList;
	}
	
	public boolean add(T task) {
		return taskList.add(task);
	}
	
	public boolean addAll(TaskList<T> addedList) {
		return taskList.addAll(addedList.getInternalList());
	}
	
	public boolean delete(T task) {
		return taskList.remove(task);
	}
	
	public int size() {
		return taskList.size();
	}
	
	public TaskList<T> search(Predicate<T> predicate) {
		TaskList<T> results = new TaskList<T>();
		for (T task: taskList) {
			if (predicate.test(task)) {
				results.add(task);
			}
		}
		return results;
	}
	
	public TaskList<Task> search(TaskList<Task> results, Predicate<Task> predicate) {
		for (T task: taskList) {
			if (predicate.test(task)) {
				results.add(task);
			}
		}
		return results;
	}
}
```
###### Test\logic\TestAdd.java
``` java
 * This class tests add feature of the Logic
 */
public class TestAdd {
	
	@Test
	public void testAdd() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		ArrayList<String> taskList = new ArrayList<String>();
		taskList.add(task.toString());
		Response addResponse = new Response("Task added successfully", taskList);
		assertEquals(addResponse.toString(), TaskProcessor.executeCommand(commandAdd).toString());
	}
	
}
```
###### Test\logic\TestAddUndo.java
``` java
 * this class tests the undo method of Add
 */
import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandUndo;
import logic.tasks.Deadline;
import storage.Storage;

public class TestAddUndo {
	
	@Test
	public void testAdd() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		TaskProcessor.executeCommand(commandAdd);
		Command commandUndo = new CommandUndo();
		ArrayList<String> taskList = new ArrayList<String>();
		Response undoResponse = new Response("Command undone successfully", taskList);
		assertEquals(undoResponse, TaskProcessor.executeCommand(commandUndo));
	}
}
```
###### Test\logic\TestDelete.java
``` java
 * This class tests the delete feature of Logic
 */
import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandDelete;
import logic.tasks.Deadline;
import storage.Storage;

public class TestDelete {
	
	@Test
	public void testDelete() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		TaskProcessor.executeCommand(commandAdd);
		Command commandDelete = new CommandDelete(1);
		ArrayList<String> taskList = new ArrayList<String>();
		assertEquals(taskList, TaskProcessor.executeCommand(commandDelete));
	}
}
```
###### Test\logic\TestDeleteUndo.java
``` java
 * This class tests the undo method of Delete
 */

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandDelete;
import logic.commands.CommandUndo;
import logic.tasks.Deadline;
import storage.Storage;

public class TestDeleteUndo {
	
	@Test
	public void testAdd() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		TaskProcessor.executeCommand(commandAdd);
		Command commandDelete = new CommandDelete(1);
		TaskProcessor.executeCommand(commandDelete);
		Command commandUndo = new CommandUndo();
		ArrayList<String> taskList = new ArrayList<String>();
		taskList.add(task.toString());
		Response undoResponse = new Response("Command undone successfully", taskList);
		assertEquals(undoResponse, TaskProcessor.executeCommand(commandUndo));
	}
}
```
