# A0112184R
###### src\gui\Controller.java
``` java
    public static void main(String args[]) throws Exception{
        initialize();
    }
```
###### src\gui\Controller.java
``` java
     * initialize the display window and all logic's components
     */
	public static void initialize() throws Exception {
    	DW = new DisplayWindow();
        DW.setVisible(true);
		TaskProcessor.initialize();
		displayTasks(TaskProcessor.getListToDisplay(), INCOMPLETE);
	}
```
###### src\logic\commands\Command.java
``` java
 * This interface represents the commands entered by the user
 */
public interface Command {
	
	public CommandType getType();
	
	public String execute();
	
	public String undo();
	
}
```
###### src\logic\commands\CommandAdd.java
``` java
 * Class CommandAdd: This class encapsulates the "add" commands from the user.
 */
public class CommandAdd implements Command {
	
	private static final String MESSAGE_TASK_ADDED = "Task added successfully";
	private static final String MESSAGE_ADD_ERROR = "Error encountered when adding task. Please try again.";
	private static final String MESSAGE_UNDONE = "Action undone: add %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Failed to undo action: add %1$s";
	
	private final Task task;
	
	public CommandAdd(Task task) {
		assert task != null: "Attempt to create a null task";
		this.task = task;
	}
	
	public Task getTask() {
		return task;
	}
	
	public CommandType getType() {
		return CommandType.ADD;
	}

	public String execute() {
		LogicLogger.log(Level.INFO, "adding task: " + task.toString() + " to storage");
		try {
			StorageController.addNewTask(task);
			StorageController.setTabType("incomplete");
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "added successfully");
			return MESSAGE_TASK_ADDED;
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when adding to storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_ADD_ERROR;
		}
	}

	public String undo() {
		LogicLogger.log(Level.INFO, "deleting task: " + task.toString() + " from storage");
		try {
			StorageController.deleteTask(task);
			LogicLogger.log(Level.INFO, "undone successfully");
			return String.format(MESSAGE_UNDONE, task.toString());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return String.format(MESSAGE_UNDO_ERROR, task.toString());
		}
	}
	
}
```
###### src\logic\commands\CommandClear.java
``` java
 * This class contains details for "clear" commands
 */
public class CommandClear implements Command {
	
	private static final String MESSAGE_CLEARED = "All tasks removed";
	private static final String MESSAGE_UNDONE = "All tasks added back";
	private static final String MESSAGE_CLEAR_ERROR = "Error: fail to clear tasks";
	
	private ArrayList<Task> oldTaskList;
	
	public CommandType getType() {
		return CommandType.CLEAR;
	}
	
	public CommandClear() {
		oldTaskList = new ArrayList<Task>();
	}
	
	public String execute() {
		try {
			for (Task task: StorageController.getDisplayList()) {
				oldTaskList.add(task);
			}
			StorageController.clearDisplayedTasks();
			return MESSAGE_CLEARED;
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_CLEAR_ERROR;
		}
	}
	
	public String undo() {
		assert (oldTaskList != null) : "task list is null";
		String message = null;
		try {
			for (Task task: oldTaskList) {
				StorageController.addNewTask(task);
			}
			message = MESSAGE_UNDONE;
		} catch (IOException e) {
			message = e.toString();
		}
		return message;
	}
}
```
###### src\logic\commands\CommandDelete.java
``` java
 * This class encapsulates the "delete" commands from the user.
 */
public class CommandDelete implements Command {
	
	private static final String MESSAGE_DELETE_ERROR = "Error encountered when deleting task";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task number %s not found in task list";
	private static final String MESSAGE_TASK_DELETED = "Task deleted: %1$s";
	private static final String MESSAGE_UNDONE = "Task added back to task list: %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Failed to undo action: delete %1$s";
	
	private int taskNumberToDelete;
	private Task deletedTask;
	
	public CommandDelete(int taskNumber) {
		taskNumberToDelete = taskNumber;
		deletedTask = null;
	}
	
	public CommandType getType() {
		return CommandType.DELETE;
	}
	
	public String execute() {
		try {
			deletedTask = StorageController.deleteByIndex(taskNumberToDelete-1);
			LogicLogger.log(Level.INFO, "deleting task: " + deletedTask.toString() + " from storage");
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "deleted successfully");
			return String.format(MESSAGE_TASK_DELETED, deletedTask.toString());
		} catch (IndexOutOfBoundsException d) {
			LogicLogger.log(Level.WARNING, "Task not found");
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToDelete);
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_DELETE_ERROR;
		}
	}

	public String undo() {
		LogicLogger.log(Level.INFO, "adding task back: " + deletedTask.toString() + " to storage");
		try {
			StorageController.addNewTask(deletedTask);
			StorageController.setTabType("incomplete");
			LogicLogger.log(Level.INFO, "undone successfully");
			return String.format(MESSAGE_UNDONE, deletedTask.toString());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when adding from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return String.format(MESSAGE_UNDO_ERROR, deletedTask.toString());
		}
	}

}
```
###### src\logic\commands\CommandDisplay.java
``` java
 * This class contains details for the "display" commands
 */
public class CommandDisplay implements Command {
	
	private static final String MESSAGE_ALL_TASKS = "All tasks are displayed below:";
	private static final String MESSAGE_FLOAT_TASKS = "All undecided tasks are displayed below:";
	private static final String MESSAGE_DEADLINES = "All deadlines are displayed below:";
	private static final String MESSAGE_SESSIONS = "All sessions are displayed below:";
	private static final String MESSAGE_RECURRING = "All recurring tasks are displayed below:";
	private static final String MESSAGE_DISPLAY_DATE = "All tasks on %s are displayed below:";
	private static final String MESSAGE_INVALID = "Invalid criteria for display. Please try again";
	private static final String MESSAGE_INCOMPLETE = "All incomplete tasks are displayed below:";
	private static final String MESSAGE_COMPLETED = "All completed tasks are displayed below:";
	private static final String MESSAGE_UPCOMING = "All tasks of today and tomorrow are displayed below:";
	private String criteria;

	public CommandType getType() {
		return CommandType.DISPLAY;
	}
	
	public CommandDisplay(String word) {
		criteria = word;
	}
	
	public CommandDisplay() {
		criteria = "all";
	}
	
	public String execute() {
		if (criteria.equals("all")) {
			StorageController.setTabType("all");
			return MESSAGE_ALL_TASKS;
		} else if (criteria.equals("float")) {
			StorageController.setTabType("all");
			StorageController.displayFloatTasks();
			return MESSAGE_FLOAT_TASKS;
		} else if (criteria.equals("deadline")) {
			StorageController.setTabType("all");
			StorageController.displayDeadlines();
			return MESSAGE_DEADLINES;
		} else if (criteria.equals("session")) {
			StorageController.setTabType("all");
			StorageController.displaySessions();
			return MESSAGE_SESSIONS;
		} else if (criteria.equals("recurring")) {
			StorageController.setTabType("all");
			StorageController.displayRecurring();
			return MESSAGE_RECURRING;
		} else if (criteria.equals("undone")) {
			StorageController.setTabType("incomplete");
			return MESSAGE_INCOMPLETE;
		} else if (criteria.equals("done")) {
			StorageController.setTabType("completed");
			return MESSAGE_COMPLETED;
		} else if (criteria.equals("upcoming")) {
			StorageController.setTabType("upcoming");
			return MESSAGE_UPCOMING;
		} else {
			Calendar date = TaskUtil.parseDate(criteria);
			if (date != null) {
				StorageController.setTabType("all");
				StorageController.displayTasksOnDate(date);
				return String.format(MESSAGE_DISPLAY_DATE, criteria);
			} else {
				return MESSAGE_INVALID;
			}
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandEdit.java
``` java
 * This class contains details for "edit" commands
 */
public class CommandEdit implements Command {
	
	private static final String MESSAGE_EDITED = "Task edited: %1$s";
	private static final String MESSAGE_TASK_NOT_FOUND = "Task %1$s not found in task list";
	private static final String MESSAGE_EDIT_ERROR = "Error encountered when editing task";
	private static final String MESSAGE_UNDONE = "Task reverted: %1$s";
	private static final String MESSAGE_UNDO_ERROR = "Error when undoing action: edit %1$s";
	
	private int taskNumberToEdit;
	private Task editedTask;
	private Task oldTask;
	
	public CommandEdit(int taskNumber,Task task) {
		taskNumberToEdit = taskNumber;
		editedTask = task;
	}
	
	public CommandType getType() {
		return CommandType.EDIT;
	}
	
	public String execute() {
		LogicLogger.log(Level.INFO, "editing task: " + editedTask.toString() + " in storage");
		try {
			oldTask = StorageController.deleteByIndex(taskNumberToEdit-1);
			System.out.println(TaskUtil.toString(editedTask));
			String titleString = editedTask.getTitle();
			Calendar start = editedTask.getStartDate();
			Calendar end = editedTask.getEndDate();
			int period = editedTask.getPeriod();
			
			if (titleString.equals("unspecified title")) {
				titleString = oldTask.getTitle();
			}
			if (start == null) {
				start = oldTask.getStartDate();
			}
			if (end == null) {
				end = oldTask.getEndDate();
			}
			if (period == 0) {
				period = oldTask.getPeriod();
			}
			editedTask = TaskUtil.getInstance(titleString, start, end, period);
			System.out.println(TaskUtil.toString(editedTask));
			
			StorageController.addNoSwitchTab(taskNumberToEdit-1, editedTask);
			ExecutedCommands.addCommand(this);
			LogicLogger.log(Level.INFO, "edited successfully");
			return String.format(MESSAGE_EDITED, editedTask.toString());
		} catch (IndexOutOfBoundsException d) {
			LogicLogger.log(Level.WARNING, "Task not found");
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumberToEdit);
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when deleting from storage:");
			LogicLogger.log(Level.SEVERE, e.toString());
			return MESSAGE_EDIT_ERROR;
		}
	}
	
	public String undo() {
		try {
			StorageController.deleteTask(editedTask);
			StorageController.addNoSwitchTab(taskNumberToEdit-1, oldTask);
			return String.format(MESSAGE_UNDONE, oldTask.toString());
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_UNDO_ERROR, oldTask.toString());
		}
	}
}
```
###### src\logic\commands\CommandGetLocation.java
``` java
 * This class contains details for the get location command
 */
public class CommandGetLocation implements Command {
	
	private static final String MESSAGE_LOCATION = "Storage location is: %s";

	public CommandType getType() {
		return CommandType.GET;
	}
	
	public CommandGetLocation() {}
	
	public String execute() {
		return String.format(MESSAGE_LOCATION, StorageController.getPath());
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandInvalid.java
``` java
 * This class signifies invalid commands
 */
public class CommandInvalid implements Command {
	
	private static final String MESSAGE_INVALID_COMMAND = "Invalid command. Please try again.";
	
	public CommandType getType() {
		return CommandType.INVALID;
	}
	
	public CommandInvalid() { }
	
	public String execute() {
		return MESSAGE_INVALID_COMMAND;
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandMark.java
``` java
 * This class contains details for the mark as done commands
 */
public class CommandMark implements Command {
	
	private static final String MESSAGE_TASK_MARKED = "Task completed: %s";
	private static final String MESSAGE_MARK_ERROR = "Error: failed to mark task as done";
	private static final String MESSAGE_TASK_DONE = "Task is already done";
	private static final String MESSAGE_TASK_UNMARKED = "Task is unmarked: %s";
	private static final String MESSAGE_UNMARK_ERROR = "Error: failed to unmark task";
<<<<<<< HEAD
	private static final String MESSAGE_TASK_NOT_FOUND = "Task not found: %s";
=======
	private static final String MESSAGE_TASK_NOT_FOUND = "Task number %s not found in task list";
>>>>>>> 9a9e865c0749c398f03055730beb5bde91c3517a
	private int taskNumber;
	private Task task;
	
	public CommandMark(int inputNum) {
		taskNumber = inputNum;
	}
	
	public CommandType getType() {
		return CommandType.MARK;
	}
	
	public String execute() {
		try {
			task = StorageController.getIndex(taskNumber-1);
			if (task.isDone()) {
				return MESSAGE_TASK_DONE;
			}
			task.markDone();
			StorageController.markDoneByIndex(taskNumber-1);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_TASK_MARKED, task.toString());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_MARK_ERROR;
<<<<<<< HEAD
		} catch (IndexOutOfBoundsException d) {
=======
		} catch (IndexOutOfBoundsException e) {
>>>>>>> 9a9e865c0749c398f03055730beb5bde91c3517a
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumber);
		}
	}
	
	public String undo() {
		try {
			assert (task != null): "Task is null";
			assert (task.isDone()): "Task is somehow not done";
			StorageController.unmarkDone(task);
			StorageController.setTabType("incomplete");
			task.unmark();
			return String.format(MESSAGE_TASK_UNMARKED, task.toString());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_UNMARK_ERROR;
		}
	}
}
```
###### src\logic\commands\CommandRedo.java
``` java
 *
 */
public class CommandRedo implements Command {
	
	private static final String MESSAGE_NO_COMMAND = "No undone commands";

	public CommandType getType() {
		return CommandType.REDO;
	}
	
	public CommandRedo() {}
	
	public String execute() {
		if (!UndoneCommands.isEmpty()) {
			Command lastUndoneCommand = UndoneCommands.getLatestCommand();
			LogicLogger.log(Level.INFO, "Undoing action");
			return lastUndoneCommand.execute();
		} else {
			LogicLogger.log(Level.INFO, "No action to undo");
			return MESSAGE_NO_COMMAND;
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandSearch.java
``` java
 * This class contains details for "search" commands
 */
public class CommandSearch implements Command {
	
	private static final String MESSAGE_SEARCH_RESULT = "Search results for %1$s:";
	
	private String keyword;
	
	public CommandType getType() {
		return CommandType.SEARCH;
	}
	
	public CommandSearch(String word) {
		keyword = word;
	}
	
	public String execute() {
		
		Predicate<Task> searchPredicate = new Predicate<Task>() {
			public boolean test(Task task) {
				String titleString = task.getTitle().toLowerCase();
				String[] keys;
				if (keyword.startsWith("\"") && keyword.endsWith("\"")) {
					keys = new String[]{ keyword };
				} else {
					keys = keyword.toLowerCase().split("\\s+");
				}
				boolean result = false;
				for (String word: keys) {
					if (titleString.contains(word)) {
						result = true;
					}
				}
				return result;
			}
		};
		
		StorageController.searchTask(searchPredicate);
		return String.format(MESSAGE_SEARCH_RESULT, keyword);
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandSetLocation.java
``` java
 * This class contains details for the "set location" commands
 */
import java.io.IOException;

import logic.ExecutedCommands;
import storage.StorageController;

public class CommandSetLocation implements Command {
	
	private static final String MESSAGE_LOCATION_SET = "storage location set to: %1$s";
	private static final String MESSAGE_UNDONE = "storage location reverted to: %1$s";
	private static final String MESSAGE_SET_ERROR = "Failed to set storage location to: %1$s";
	
	private String newPathName;
	private String oldPathName;
	
	public CommandType getType() {
		return CommandType.SET;
	}
	
	public CommandSetLocation(String pathName) {
		newPathName = pathName;
	}
	
	public String execute() {
		try {
			oldPathName = StorageController.getPath();
			StorageController.setPath(newPathName);
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_LOCATION_SET, newPathName);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_SET_ERROR, newPathName);
		}
	}
	
	public String undo() {
		try {
			StorageController.setPath(oldPathName);
			return String.format(MESSAGE_UNDONE, oldPathName);
		} catch (IOException e) {
			e.printStackTrace();
			return String.format(MESSAGE_SET_ERROR, oldPathName);
		}
	}
}
```
###### src\logic\commands\CommandType.java
``` java
 * enum CommandType: contains possible types for user commands.
 */
package logic.commands;

public enum CommandType {
	ADD, DELETE, CLEAR, DISPLAY, INVALID, UNDO, MARK, UNMARK, EDIT, SEARCH, SET, HELP, REDO, GET;
}
```
###### src\logic\commands\CommandUndo.java
``` java
 * This class contains details for "undo" commands
 */
public class CommandUndo implements Command {
	
	private static final String MESSAGE_COMMAND_UNDONE = "Command undone successfully";
	private static final String MESSAGE_NO_COMMAND = "No command to undo";

	public CommandType getType() {
		return CommandType.UNDO;
	}
	
	public CommandUndo() {}
	
	public String execute() {
		if (!ExecutedCommands.isEmpty()) {
			Command lastExecutedCommand = ExecutedCommands.getLatestCommand();
			LogicLogger.log(Level.INFO, "Undoing action");
			UndoneCommands.addCommand(lastExecutedCommand);
			return lastExecutedCommand.undo();
		} else {
			LogicLogger.log(Level.INFO, "No action to undo");
			return MESSAGE_NO_COMMAND;
		}
	}
	
	public String undo() {
		return null;
	}
}
```
###### src\logic\commands\CommandUnmark.java
``` java
 * This class contains details for the unmark commands
 */
public class CommandUnmark implements Command {
	
	private static final String MESSAGE_TASK_MARKED = "Task marked as done again: %s";
	private static final String MESSAGE_MARK_ERROR = "Error: failed to mark task as done";
	private static final String MESSAGE_TASK_NOT_DONE = "Task is already not done";
	private static final String MESSAGE_TASK_UNMARKED = "Task is unmarked: %s";
	private static final String MESSAGE_UNMARK_ERROR = "Error: failed to unmark task";
<<<<<<< HEAD
	private static final String MESSAGE_TASK_NOT_FOUND = "Task not found: %s";
	
=======
	private static final String MESSAGE_TASK_NOT_FOUND = "Task number %s not found in task list";
>>>>>>> 9a9e865c0749c398f03055730beb5bde91c3517a
	private int taskNumber;
	private Task task;
	
	public CommandUnmark(int inputNum) {
		taskNumber = inputNum;
	}
	
	public CommandType getType() {
		return CommandType.UNMARK;
	}
	
	public String execute() {
		try {
			task = StorageController.getIndex(taskNumber-1);
			if (!task.isDone()) {
				return MESSAGE_TASK_NOT_DONE;
			}
			StorageController.unmarkDoneByIndex(taskNumber-1);
			task.unmark();
			ExecutedCommands.addCommand(this);
			return String.format(MESSAGE_TASK_UNMARKED, task.toString());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_UNMARK_ERROR;
<<<<<<< HEAD
		}  catch (IndexOutOfBoundsException d) {
=======
		} catch (IndexOutOfBoundsException e) {
>>>>>>> 9a9e865c0749c398f03055730beb5bde91c3517a
			return String.format(MESSAGE_TASK_NOT_FOUND, taskNumber);
		}
	}
	
	public String undo() {
		try {
			assert (task != null): "Task is null";
			assert (!task.isDone()): "Task is somehow done";
			StorageController.markDone(task);
			task.markDone();
			return String.format(MESSAGE_TASK_MARKED, task.toString());
		} catch (IOException e) {
			e.printStackTrace();
			return MESSAGE_MARK_ERROR;
		}
	}
}
```
###### src\logic\ExecutedCommands.java
``` java
 * This stack contains the executed commands
 * Each time an undo is executed, the top of the stack is popped out and undone
 */
public class ExecutedCommands {
	
	public static Stack<Command> executedCommands;
	
	public static Command getLatestCommand() {
		return executedCommands.pop();
	}
	
	public static boolean addCommand(Command command) {
		return executedCommands.add(command);
	}
	
	public static boolean isEmpty() {
		return executedCommands.isEmpty();
	}
	
	public static int getSize() {
		return executedCommands.size();
	}
	
	public static void initialize() {
		executedCommands = new Stack<Command>();
	}
}
```
###### src\logic\LogicLogger.java
``` java
 * Logger for Logic
 */
import java.util.logging.Level;
import java.util.logging.Logger;

public class LogicLogger {
	
	public static Logger logicLogger;
	
	public static void initialize() {
		logicLogger = Logger.getLogger("LogicLogger");
	}
	
	public static void log(Level level, String message) {
		logicLogger.log(level, message);
	}
}
```
###### src\logic\Priority.java
``` java
 * enum type containing the possible values for a task's priority
 */

package logic;

public enum Priority {
	URGENT, HIGH, MEDIUM, LOW, NULL;
}
```
###### src\logic\Response.java
``` java
 * This class contains all the information the Logic send to the UI for displaying
 */
public class Response {
	
	private String message;
	private ArrayList<String> taskList;
	private String type;
        
	
	public Response(String msg, String tabType, ArrayList<String> list) {
		message = msg;
		taskList = list;
		type = tabType;
	}
	
	public Response(String msg, ArrayList<String> list) {
		message = msg;
		taskList = list;
		type = "incomplete";
	}
	
	public Response(String msg) {
		message = msg;
	}
	
	public Response(ArrayList<String> list) {
		taskList = list;
	}
	
	public String getMessage() {
		return message;
	}
	
	public ArrayList<String> getTaskList() {
		return taskList;
	}
	
	public boolean equals(Response res) {
		return (getMessage().equals(res.getMessage()) && getTaskList().equals(res.getTaskList()));
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append(getMessage());
		if (taskList == null) {
			sb.append("\r\n");
			sb.append("null");
		} else {
			for (String str: taskList) {
				sb.append("\r\n");
				sb.append(str);
			}
		}
		return sb.toString();
	}


	public String getType() {
		return type;
	}
	
	public void setType(String newType) {
		type = newType;
	}
}
```
###### src\logic\TaskProcessor.java
``` java
 * Class TaskProcessor
 * This class contains methods to execute all the user commands and issue commands to other components.
 * Key methods so far:
 *     - executeCommand(Command): execute the Command object by calling Command.execute()
 *     - executeInput(String): execute the input by parsing it and call executeCommand
 *     - initialize: initialize the StorageController and all the components
 */
public class TaskProcessor {
	
	/*
	private static final String MESSAGE_DISPLAY_ERROR = "Error encountered when displaying tasks. Please try again";
	private static final String MESSAGE_CLEAR_ERROR = "Error encountered when clearing all tasks. Please try again";
	private static final String MESSAGE_SORT_ERROR = "Error encountered when sorting tasks. Please try again.";
	*/

	private static ArrayList<String> listToDisplay;
	
	public static void main(String[] args) {
		while (true) {
			getAndExecuteCommand();
		}
	}
	
	public static ArrayList<String> getListToDisplay() {
		loadIntoDisplayList(StorageController.getDisplayList());
		return listToDisplay;
	}
	
	public static void getAndExecuteCommand() {
		Command command = CommandQueue.getCommand();
		if (command != null) {
			executeCommand(command);
		}
	}
	
	public static Response executeInput(String input) {
		LogicLogger.log(Level.INFO, "Executing input: " + input);
		Command command = CommandParser.parseInput(input);
		return executeCommand(command);
	}

	public static Response executeCommand(Command command) {
		String message = command.execute();
		ArrayList<String> taskList = getListToDisplay();
		return new Response(message, StorageController.getTabType(), taskList);
	}
	
	public static void initialize() {
		listToDisplay = new ArrayList<String>();
		ExecutedCommands.initialize();
		UndoneCommands.initialize();
		LogicLogger.initialize();
		try {
			LogicLogger.log(Level.INFO, "Initializing StorageController");
			StorageController.initialize();
			loadIntoDisplayList(StorageController.getDisplayList());
		} catch (IOException e) {
			LogicLogger.log(Level.SEVERE, "Error when initializing StorageController");
			e.printStackTrace();
		}
	}
	
	private static void loadIntoDisplayList(ArrayList<Task> taskList) {
		LogicLogger.log(Level.INFO, "Loading list to display from StorageController");
		listToDisplay.clear();
		for (Task task: taskList) {
			assert task != null : "Some task in the task list is null";
			listToDisplay.add(TaskUtil.toString(task));
		}
	}
	
	public static ArrayList<String[]> getTimelineList() {
		ArrayList<String[]> result = new ArrayList<String[]>();
		for (Task task: StorageController.getTimelineList()) {
			String[] pentuple = TaskUtil.toStringArray(task);
			String[] triple = new String[3];
			for (int i=0; i<3; i++) {
				triple[i] = pentuple[i+1];
			}
			result.add(triple);
		}
		return result;
	}
}
```
###### src\logic\tasks\Deadline.java
``` java
 * This class stores all the information in a task.
 * Fields:
 *     - title: details about the task
 *     - date: Calendar for the task to be done or deadline
 *     - priority: the task's priority
 */
public class Deadline extends Task {

	private Calendar date;
	private Priority priority;
	
	@Override
	public TaskType getType() {
		return TaskType.NORMAL;
	}
	
	@Override
	public Calendar getStartDate() {
		return date;
	}
	
	public Calendar getDate() {
		return date;
	}
	
	public Priority getPriority() {
		return priority;
	}
	
	public void setDate(Calendar newDate) {
		date = newDate;
	}
	
	public void setPriority(Priority newPrio) {
		priority = newPrio;
	}
	
	public Deadline(String title, Calendar date, Priority priority) {
		super(title);
		this.date = date;
		this.priority = priority;
	}
	
	public Deadline(String title, Calendar date) {
		this(title, date, Priority.NULL);
	}
	
	public Deadline(String title) {
		this(title, Calendar.getInstance(), Priority.NULL);
	}
	
	@Override
	public String toString() {
		String result = getTitle() + " " + getDateString(date);
		return result;
	}
	
	public boolean equals(Deadline otherTask) {
		return (getTitle().equals(otherTask.getTitle()) && getDate().equals(otherTask.getDate()));
	}
	
	public Deadline clone() {
		Deadline copiedTask = new Deadline(title, date);
		return copiedTask;
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Deadline) {
			return (((Deadline) obj).getType() == this.getType())
					&& ((Deadline) obj).getTitle().equalsIgnoreCase(this.getTitle())
					&& ((Deadline) obj).getDate().equals(this.getDate());
		}
		return false;
	}
}
```
###### src\logic\tasks\RecurringTask.java
``` java
 * This class contains details for recurring tasks
 */
public class RecurringTask extends Task {
	
	private static final String DAILY = "every day";
	private static final String WEEKLY = "every week";
	private static final String MONTHLY = "every month";
	private static final String YEARLY = "every year";
	private static final String PERIODLY = "every %s day";
	private static final int EVERY_DAY = 1;
	private static final int EVERY_YEAR = -2;
	private static final int EVERY_MONTH = -1;
	private static final int EVERY_WEEK = 7;
	private Calendar startDate;
	private Calendar endDate;
	private int period;
	private List<Calendar> exceptions;
	
	@Override
	public TaskType getType() {
		return TaskType.RECUR;
	}

	public RecurringTask(String title, Calendar start, Calendar end, int time) {
		super(title);
		startDate = start;
		endDate = end;
		period = time;
		exceptions = new ArrayList<Calendar>();
	}
	
	public RecurringTask(String title, Calendar start, Calendar end) {
		this(title, start, end, EVERY_DAY);
	}
	
	public RecurringTask(String title, Calendar start, int time) {
		this(title, start, null, time);
	}
	
	public RecurringTask(String title, int time) {
		this(title, Calendar.getInstance(), time);
	}
	
	public RecurringTask(String title) {
		this(title, Calendar.getInstance(), EVERY_DAY);
	}
	
	@Override
	public Calendar getStartDate() {
		return startDate;
	}
	
	@Override
	public Calendar getEndDate() {
		return endDate;
	}
	
	@Override
	public int getPeriod() {
		return period;
	}
	
	public String getPeriodString() {
		if (period == EVERY_YEAR) {
			return YEARLY;
		} else if (period == EVERY_MONTH) {
			return MONTHLY;
		} else if (period == EVERY_WEEK) {
			return WEEKLY;
		} else if (period == EVERY_DAY) {
			return DAILY;
		} else {
			return String.format(PERIODLY, period);
		}
	}
	
	public void setStartDate(Calendar newDate) {
		startDate = newDate;
	}
	
	public void setPeriod(int newPeriod) {
		period = newPeriod;
	}
	
	private int daysUntil(Calendar date) {
		return TaskUtil.daysBetween(startDate, date);
	}
	
	private boolean isSameDayOfMonth(Calendar date) {
		return startDate.get(Calendar.DAY_OF_MONTH) == date.get(Calendar.DAY_OF_MONTH);
	}
	
	private boolean isSameDayOfYear(Calendar date) {
		return (startDate.get(Calendar.MONTH) == date.get(Calendar.MONTH))
				&& (startDate.get(Calendar.DAY_OF_MONTH) == date.get(Calendar.DAY_OF_MONTH));
	}
	
	private Calendar[] getClosestDate(Calendar[] start, Calendar des, int step) {
		Calendar[] result = new Calendar[2];
		if (des == null || start == null) {
			return null;
		}
		result[0] = Calendar.getInstance();
		result[0].setTime(start[0].getTime());
		if (start[1] != null) {
			result[1] = Calendar.getInstance();
			result[1].setTime(start[1].getTime());
		} else {
			result[1] = null;
		}
		while (DateUtils.truncatedCompareTo(result[0], des, Calendar.DATE) < 0) {
			for (Calendar cal: result) {
				if (cal != null) {
					cal.add(Calendar.DATE, step);
				}
			}
		}
		return result;
	}
	
	public boolean willOccurWithinNDays(Calendar date, int n) {
		Calendar[] closestDates = getClosestDate(new Calendar[]{startDate}, date, period);
		return TaskUtil.daysBetween(closestDates[0], startDate) <= n;
	}
	
	public boolean willOccur(Calendar date) {
		if (date.before(startDate)) {
			return false;
		}
		if (period == EVERY_YEAR) {
			return isSameDayOfYear(date);
		}
		if (period == EVERY_MONTH) {
			return isSameDayOfMonth(date);
		}
		int dayDistance = daysUntil(date);
		return (dayDistance % period) == 0;
	}
	
	public Task generate(Calendar date) {
		Calendar[] start = {startDate, endDate};
		Calendar[] cal = getClosestDate(start, date, period);
		Task result = TaskUtil.getInstance(title, cal[0], cal[1]);
		result.setRecurrence(true);
		result.setParent(this);
		return result;
	}
	
	public void addException(Calendar day) {
		boolean contains = isException(day);
		if (!contains) {
			exceptions.add(day);
		}
	}

	public boolean isException(Calendar day) {
		boolean contains = false;
		for (Calendar date: exceptions) {
			if (DateUtils.isSameDay(date, day)) {
				contains = true;
				break;
			}
		}
		return contains;
	}
	
	public void removeException(Calendar day) {
		for (Calendar date: exceptions) {
			if (DateUtils.isSameDay(date, day)) {
				exceptions.remove(date);
			}
		}
	}
	
	@Override
	public String toString() {
		if (endDate == null) {
			return getTitle() + " " + getDateString(startDate) + "every " + period + " days";
		} else {
			return getTitle() + " " + getDateString(startDate) + " - " + getDateString(endDate) + "every " + period + " days";
		}
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof RecurringTask) {
			return (((RecurringTask) obj).getType() == this.getType())
					&& ((RecurringTask) obj).getTitle().equalsIgnoreCase(this.getTitle())
					&& ((RecurringTask) obj).getStartDate().equals(this.getStartDate())
					&& ((RecurringTask) obj).getEndDate().equals(this.getEndDate())
					&& (((RecurringTask) obj).getPeriod() == this.getPeriod());
		}
		return false;
	}
}
```
###### src\logic\tasks\Session.java
``` java
 * This class contains details for sessions with start and end time
 */
public class Session extends Task {
	
	private Calendar start;
	private Calendar end;
	
	@Override
	public TaskType getType() {
		return TaskType.SESSION;
	}
	
	@Override
	public Calendar getStartDate() {
		return start;
	}
	
	public Session(String title, Calendar startDate, Calendar endDate) {
		super(title);
		start = startDate;
		end = endDate;
	}
	
	@Override
	public Calendar getEndDate() {
		return end;
	}
	
	public void setStartDate(Calendar newStart) {
		start = newStart;
	}
	
	public void setEndDate(Calendar newEnd) {
		end = newEnd;
	}
	
	@Override
	public String toString() {
		return getTitle() + " " + getDateString(start) + " - " + getDateString(end);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Session) {
			return (((Session) obj).getType() == this.getType())
					&& ((Session) obj).getTitle().equalsIgnoreCase(this.getTitle())
					&& ((Session) obj).getStartDate().equals(this.getStartDate())
					&& ((Session) obj).getEndDate().equals(this.getEndDate());
		}
		return false;
	}
}
```
###### src\logic\tasks\Task.java
``` java
 * This class encloses the general task types
 */
public class Task implements Cloneable {
	
	protected String title;
	protected boolean done;
	protected static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("dd/MM/yyyy HH:mm");
	protected boolean isRecurrence;
	protected RecurringTask parent;
	
	public TaskType getType() {
		return TaskType.FLOAT;
	}
	
	public Calendar getStartDate() {
		return null;
	}
	
	public Calendar getEndDate() {
		return null;
	}
	
	public int getPeriod() {
		return 0;
	}
	
	public Task(String title) {
		this.title = title;
		done = false;
		isRecurrence = false;
		parent = null;
	}
	
	public String getTitle() {
		if (title == null) return "unspecified title";
		return title;
	}
	
	public String setTitle(String newTitle) {
		title = newTitle;
		return newTitle;
	}
	
	public boolean isDone() {
		return done;
	}
	
	public boolean markDone() {
		done = true;
		return done;
	}
	
	public boolean unmark() {
		done = false;
		return done;
	}
	
	public boolean isRecurrence() {
		return isRecurrence;
	}
	
	public void setRecurrence(boolean recur) {
		isRecurrence = recur;
	}
	
	public RecurringTask getParent() {
		return parent;
	}
	
	public void setParent(RecurringTask task) {
		parent = task;
	}
	
	@Override
	public String toString() {
		return getTitle();
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Task) {
			return (((Task) obj).getType() == this.getType())
					&& ((Task) obj).getTitle().equalsIgnoreCase(this.getTitle());
		}
		return false;
	}
	
	protected static String getDateString(Calendar date) {
		if (date == null) {
			return "null";
		} else {
			return DATE_FORMAT.format(date.getTime());
		}
	}

	public void setDone(boolean isDone) {
		done = isDone;
	}
}
```
###### src\logic\tasks\TaskType.java
``` java
 * This enum contains the possible task types
 */
public enum TaskType {
	FLOAT, NORMAL, SESSION, RECUR;
}
```
###### src\logic\tasks\TaskUtil.java
``` java
 * This class contains the getInstance() method to generate a Task object
 * and the comparator for tasks
 */
public class TaskUtil {
	
	private static final String NULL_TIME = "-";
	private static final String FIELD_SEPARATOR = ";";
	private static final SimpleDateFormat STORAGE_FORMAT = new SimpleDateFormat("HH:mm yyyyMMdd", Locale.ENGLISH);
	private static final SimpleDateFormat DISPLAY_FORMAT = new SimpleDateFormat("dd MMM HH:mm", Locale.ENGLISH);

	public static class TaskComparator implements Comparator<Task> {
		public int compare(Task task1, Task task2) {
			int dateComp;
			Calendar date1 = task1.getStartDate();
			Calendar date2 = task2.getStartDate();
			if (date1 == null && date2 == null) {
				dateComp = task1.getTitle().compareToIgnoreCase(task2.getTitle());
			} else if (date1 == null) {
				dateComp = 1;
			} else if (date2 == null) {
				dateComp = -1;
			} else {
				dateComp = date1.compareTo(date2);
			}
			if (dateComp != 0) {
				return dateComp;
			} else {
				return task1.getTitle().compareToIgnoreCase(task2.getTitle());
			}
		}
	}
	
	public static Task getInstance(String title, Calendar startDate, Calendar endDate, int recurringPeriod) {
		if (startDate == null && endDate == null) {
			return new Task(title);
		} else if (recurringPeriod != 0) {
			return new RecurringTask(title, startDate, endDate, recurringPeriod);
		} else if (endDate == null){
			return new Deadline(title, startDate);
		} else {
			return new Session(title, startDate, endDate);
		}
	}
	
	public static Task getInstance(String title, Calendar startDate, Calendar endDate) {
		return getInstance(title, startDate, endDate, 0);
	}
	
	public static Task getInstance(String title, Calendar startDate, int recurringPeriod) {
		return getInstance(title, startDate, null, recurringPeriod);
	}
	
	public static Task getInstance(String title, Calendar startDate) {
		return getInstance(title, startDate, null, 0);
	}
	
```
###### src\logic\TextUI.java
``` java
 * This class is used to test the program when the GUI was in progress
 */
package logic;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Scanner;

import Parser.CommandParser;
import logic.commands.Command;

public class TextUI {
	
	private static Scanner sc;
	
	public static void main(String[] args) {
		sc = new Scanner(System.in);
		initialize();
		while (sc.hasNextLine()) {
			String input = sc.nextLine();
			Response response = executeInput(input);
			displayResponse(response, System.out);
		}
		sc.close();
	}
	
	public static void mainFileToFile(File inputFile, File outputFile) throws FileNotFoundException {
		sc = new Scanner(inputFile);
		PrintStream pr = new PrintStream(outputFile);
		initialize();
		while (sc.hasNextLine()) {
			String input = sc.nextLine();
			Response response = executeInput(input);
			displayResponse(response, pr);
		}
		sc.close();
		pr.close();
	}

	private static Response executeInput(String input) {
		Command command = CommandParser.parseInput(input);
		Response response = TaskProcessor.executeCommand(command);
		return response;
	}
	
	public static void displayResponse(Response response, PrintStream printer) {
		if (response != null) {
			displayMessage(response.getMessage(), printer);
			displayTaskList(response.getTaskList(), printer);
		}
	}
	
	public static void displayMessage(String message, PrintStream printer) {
		printer.println(message);
	}
	
	public static void displayTaskList(ArrayList<String> taskList, PrintStream printer) {
		if (taskList != null) {
			if (!taskList.isEmpty()) {
				int lineNum = 0;
				for (String task: taskList) {
					lineNum++;
					printer.print(lineNum + ". ");
					printer.println(task);
				}
			} else {
				printer.println("No tasks to show");
			}
		} else {
			printer.println("Task list not loaded");
		}
	}
	
	public static void getInput() {
		String input = sc.nextLine();
		InputQueue.addInput(input);
	}
	
	public static void initialize() {
		ExecutedCommands.initialize();
		TaskProcessor.initialize();
	}
}
```
###### src\logic\UndoneCommands.java
``` java
 *
 */
public class UndoneCommands {
	
	public static Stack<Command> undoneCommands;
	
	public static Command getLatestCommand() {
		return undoneCommands.pop();
	}
	
	public static boolean addCommand(Command command) {
		return undoneCommands.add(command);
	}
	
	public static boolean isEmpty() {
		return undoneCommands.isEmpty();
	}
	
	public static int getSize() {
		return undoneCommands.size();
	}
	
	public static void initialize() {
		undoneCommands = new Stack<Command>();
	}
}
```
###### src\storage\Database.java
``` java
 * This class is responsible for reading and writing from the storage file
 */
public class Database {
	
	private static final String CONFIG_FILE_NAME = "./src/document/config.txt";
	private static final String DIRECTORY_NAME = "%s/data";
	private static final String FLOAT_LIST_FILE_NAME = "%s/data/floatList.txt";
	private static final String DEADLINE_LIST_FILE_NAME = "%s/data/deadlineList.txt";
	private static final String SESSION_LIST_FILE_NAME = "%s/data/sessionList.txt";
	private static final String RECURRING_LIST_FILE_NAME = "%s/data/recurringList.txt";
	private static final String DONE_LIST_FILE_NAME = "%s/data/doneList.txt";
	
	private static File configFile;
	
	private static String storagePath;
	
	private static File floatListFile;
	private static File deadlineListFile;
	private static File sessionListFile;
	private static File recurringListFile;
	private static File doneListFile;
	
	public static void retrieveFiles() throws IOException {
		String directoryName = getStorageDirectory();
		File data = new File(String.format(DIRECTORY_NAME, directoryName));
		if (!data.exists()) {
			StorageLogger.log(Level.INFO, "Creating storage folder");
			if (data.mkdirs()) {
				StorageLogger.log(Level.INFO, "Storage folder created");
			} else {
				StorageLogger.log(Level.SEVERE, "Storage folder not created");
			}
		}
		floatListFile = initFile(String.format(FLOAT_LIST_FILE_NAME, directoryName));
		deadlineListFile = initFile(String.format(DEADLINE_LIST_FILE_NAME, directoryName));
		sessionListFile = initFile(String.format(SESSION_LIST_FILE_NAME, directoryName));
		recurringListFile = initFile(String.format(RECURRING_LIST_FILE_NAME, directoryName));
		doneListFile = initFile(String.format(DONE_LIST_FILE_NAME, directoryName));
	}
	
	static File initFile(String filename) throws IOException {
		StorageLogger.log(Level.INFO, "Initializing file: " + filename);
		File result = new File(filename);
		if (!result.exists()) {
			result.createNewFile();
		}
		return result;
	}

	private static String getStorageDirectory() throws FileNotFoundException {
		Scanner sc = new Scanner(configFile);
		String storagePath;
		if (sc.hasNextLine()) {
			storagePath = sc.nextLine().trim();
		} else {
			storagePath = ".";
		}
		sc.close();
		return storagePath;
	}
	
	public static void initialize() throws IOException {
		StorageLogger.initialize();
		configFile = initFile(CONFIG_FILE_NAME);
		retrieveFiles();
		load();
	}

	public static void setPath(String pathName) throws IOException{
		configFile.delete();
		configFile.createNewFile();
		BufferedWriter bf = initBufferedWriter(configFile);
		bf.write(pathName);
		bf.newLine();
		bf.close();
		retrieveFiles();
		save();
	}
	
	public static String getPath() {
		return storagePath;
	}
	
	public static void clear() throws IOException {
		clearFile(floatListFile);
		clearFile(deadlineListFile);
		clearFile(sessionListFile);
		clearFile(recurringListFile);
		clearFile(doneListFile);
	}
	
	public static void clearFile(File file) throws IOException {
		Files.delete(file.toPath()); // delete the whole file and
		file.createNewFile(); // create a new empty file with the same name
	}

	private static BufferedReader initBufferedReader(File textFile) throws FileNotFoundException {
		FileReader fileReader = new FileReader(textFile.getAbsoluteFile());
		BufferedReader bufferedReader = new BufferedReader(fileReader);
		return bufferedReader;
	}

	private static BufferedWriter initBufferedWriter(File textFile) throws IOException {
		FileWriter fileWriter = new FileWriter(textFile.getAbsoluteFile(), true);
		BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
		return bufferedWriter;
	}
	
	public static void save() throws IOException {
		saveFloat();
		saveDeadline();
		saveSession();
		saveRecurring();
		saveDone();
	}
	
	public static void saveFloat() throws IOException {
		save(GrandTaskList.getFloatList(), floatListFile);
	}
	
	public static void saveDeadline() throws IOException {
		save(GrandTaskList.getDeadlineList(), deadlineListFile);
	}
	
	public static void saveSession() throws IOException {
		save(GrandTaskList.getSessionList(), sessionListFile);
	}
	
	public static void saveRecurring() throws IOException {
		save(GrandTaskList.getRecurringList(), recurringListFile);
	}
	
	public static void saveDone() throws IOException {
		save(GrandTaskList.getDoneList(), doneListFile);
	}
	
	public static void load() throws IOException {
		loadFloat();
		loadDeadline();
		loadSession();
		loadRecurring();
		loadDone();
	}
	
	public static void loadFloat() throws IOException {
		load(GrandTaskList.getFloatList(), floatListFile);
	}
	
	public static void loadDeadline() throws IOException {
		load(GrandTaskList.getDeadlineList(), deadlineListFile);
	}
	
	public static void loadSession() throws IOException {
		load(GrandTaskList.getSessionList(), sessionListFile);
	}
	
	public static void loadRecurring() throws IOException {
		load(GrandTaskList.getRecurringList(), recurringListFile);
	}
	
	public static void loadDone() throws IOException {
		load(GrandTaskList.getDoneList(), doneListFile);
	}

	@SuppressWarnings("unchecked")
	public static <T extends Task> void load(TaskList<T> list, File file) throws IOException {
		
		BufferedReader br = initBufferedReader(file);
		String begin;
		while ((begin = br.readLine()) != null) {
			if (begin.equals("{")) {
				StringBuilder entryBuilder = new StringBuilder();
				String end;
				while (!(end = br.readLine()).equals("}")) {
					entryBuilder.append(end);
				}
				String entry = entryBuilder.toString();
				T task = (T) TaskUtil.parseFromStorage(entry);
				list.add(task);
			}
		}
		br.close();
	}
	
	public static <T extends Task> void save(TaskList<T> list, File file) throws IOException {
		clearFile(file);
		BufferedWriter bw = initBufferedWriter(file);
		for (T task: list) {
			bw.write("{\r\n");
			bw.write(TaskUtil.convertToStorage(task));
			bw.write("}\r\n");
		}
		bw.close();
	}
}
```
###### src\storage\GrandTaskList.java
``` java
 *
 */
public class GrandTaskList {
	
	private static TaskList<Task> floatTaskList;
	private static TaskList<Deadline> deadlineList;
	private static TaskList<Session> sessionList;
	private static TaskList<RecurringTask> recurringTaskList;
	
	private static TaskList<Task> doneTaskList;
	
	public static void initialize() {
		floatTaskList = new TaskList<Task>();
		deadlineList = new TaskList<Deadline>();
		sessionList = new TaskList<Session>();
		recurringTaskList = new TaskList<RecurringTask>();
		doneTaskList = new TaskList<Task>();
	}
	
	public static TaskList<Task> getFloatList() {
		return floatTaskList;
	}
	
	public static TaskList<Deadline> getDeadlineList() {
		return deadlineList;
	}
	
	public static TaskList<Session> getSessionList() {
		return sessionList;
	}
	
	public static TaskList<RecurringTask> getRecurringList() {
		return recurringTaskList;
	}
	
	public static TaskList<Task> getDoneList() {
		return doneTaskList;
	}
	
	public static TaskList<Task> getTotalList() {
		TaskList<Task> results = new TaskList<Task>();
		deadlineList.merge(results);
		sessionList.merge(results);
		recurringTaskList.merge(results);
		floatTaskList.merge(results);
		doneTaskList.merge(results);
		return results;
	}
	
	public static TaskList<Task> getNoRecurringList() {
		TaskList<Task> results = new TaskList<Task>();
		deadlineList.merge(results);
		sessionList.merge(results);
		floatTaskList.merge(results);
		return results;
	}
	
	public static TaskList<Task> getUndoneList() {
		TaskList<Task> results = new TaskList<Task>();
		deadlineList.merge(results);
		sessionList.merge(results);
		floatTaskList.merge(results);
		recurringTaskList.merge(results);
		return results;
	}
	
	public static TaskList<Task> getListByName(String name) {
		if (name.equals("all")) {
			return getTotalList();
		} else if (name.equals("upcoming")) {
			return getUpcomingList();
		} else if (name.equals("completed")) {
			return getDoneList();
		} else if (name.equals("incomplete")) {
			return getUndoneList();
		} else {
			return new TaskList<Task>();
		}
	}
	
	public static TaskList<Task> getUpcomingList() {
		return getUpComingList(2);
	}
	
	public static TaskList<Task> getUpComingList(int numDays) {
		Calendar date = Calendar.getInstance();
		TaskList<Task> result = new TaskList<Task>();
		for (int i=0; i<numDays; i++) {
			date.add(Calendar.DATE, 1);
			getTasksOnDate(date).merge(result);
		}
		return result;
	}

	public static boolean addNewTask(Task task) throws IOException {
		boolean result;
		if (task instanceof Deadline) {
			result = deadlineList.add((Deadline) task);
			Database.saveDeadline();
		} else if (task instanceof Session) {
			result = sessionList.add((Session) task);
			Database.saveSession();
		} else if (task instanceof RecurringTask) {
			result = recurringTaskList.add((RecurringTask) task);
			Database.saveRecurring();
		} else {
			result = floatTaskList.add(task);
			Database.saveFloat();
		}
		return result;
	}
	
	public static boolean deleteTask(Task task) throws IOException {
		boolean result;
		if (task instanceof Deadline) {
			result = deadlineList.delete((Deadline) task);
			Database.saveDeadline();
		} else if (task instanceof Session) {
			result = sessionList.delete((Session) task);
			Database.saveSession();
		} else if (task instanceof RecurringTask) {
			result = recurringTaskList.delete((RecurringTask) task);
			Database.saveRecurring();
		} else {
			result = floatTaskList.delete(task);
			Database.saveFloat();
		}
		return result;
	}
	
	public static boolean markDone(Task task) throws IOException {
		boolean result = deleteTask(task);
		doneTaskList.add(task);
		task.markDone();
		if (task.isRecurrence()) {
			task.getParent().addException(task.getStartDate());
		}
		Database.saveDone();
		return result;
	}
	
	public static boolean unmarkDone(Task task) throws IOException {
		boolean result = doneTaskList.delete(task);
		if (task.isRecurrence()) {
			task.getParent().removeException(task.getStartDate());
		} else {
			addNewTask(task);
			task.unmark();
		}
		Database.saveDone();
		return result;
	}
	
	public static TaskList<Task> search(Predicate<Task> predicate) {
		TaskList<Task> results = new TaskList<Task>();
		deadlineList.search(results, predicate);
		sessionList.search(results, predicate);
		recurringTaskList.search(results, predicate);
		floatTaskList.search(results, predicate);
		return results;
	}
	
	public static TaskList<Task> getTasksOnDate(Calendar date) {
		TaskList<Task> result = new TaskList<Task>();
		for (Task task: deadlineList) {
			if (TaskUtil.willOccur(task, date)) {
				result.add(task);
			}
		}
		for (Task task: sessionList) {
			if (TaskUtil.willOccur(task, date)) {
				result.add(task);
			}
		}
		for (RecurringTask task: recurringTaskList) {
			if (task.willOccur(date)) {
				result.add(task.generate(date));
			}
		}
		return result;
	}
	
	public static void clearIncomplete() {
		deadlineList.clear();
		sessionList.clear();
		recurringTaskList.clear();
		floatTaskList.clear();
	}
	
	public static void clearAll() throws IOException {
		deadlineList.clear();
		sessionList.clear();
		recurringTaskList.clear();
		floatTaskList.clear();
		doneTaskList.clear();
		Database.clear();
	}
}
```
###### src\storage\StorageController.java
``` java
 * This class controls the adding, deleting, saving, loading, searching in the storage
 */
public class StorageController {
	
	private static ArrayList<Task> displayList;
	private static String tabType;
	
	public static ArrayList<Task> getDisplayList() {
		return displayList;
	}
	
	public static String getTabType() {
		return tabType;
	}
	
	public static void setTabType(String newTab) {
		if (newTab.equals("all")) {
			displayAllTasks();
			tabType = newTab;
		} else if (newTab.equals("incomplete")) {
			displayUndoneList();
			tabType = newTab;
		} else if (newTab.equals("completed")) {
			displayDoneList();
			tabType = newTab;
		} else if (newTab.equals("upcoming")) {
			displayUpcomingList();
			tabType = newTab;
		}
	}
	
	public static void initialize() throws IOException {
		displayList = new ArrayList<Task>();
		GrandTaskList.initialize();
		Database.initialize();
		loadDisplayList();
		setTabType("incomplete");
	}
	
	public static void loadDisplayList() {
		for (Task task: GrandTaskList.getUndoneList()) {
			displayList.add(task);
		}
	}
	
	public static Task getIndex(int index) {
		return displayList.get(index);
	}
	
	public static Task deleteByIndex(int index) throws IOException {
		Task task = displayList.get(index);
		deleteTask(task);
		return task;
	}
	
	public static Task markDoneByIndex(int index) throws IOException {
		Task task = displayList.get(index);
		markDone(task);
		return task;
	}
	
	public static Task unmarkDoneByIndex(int index) throws IOException {
		Task task = displayList.get(index);
		unmarkDone(task);
		return task;
	}
	
	public static boolean addNewTask(Task task) throws IOException {
		boolean result = GrandTaskList.addNewTask(task);
		return result;
	}
	
	public static boolean addNoSwitchTab(int index, Task task) throws IOException {
		boolean result = GrandTaskList.addNewTask(task);
		displayList.add(index, task);
		return result;
	}
	
	public static boolean deleteTask(Task task) throws IOException {
		boolean result = GrandTaskList.deleteTask(task);
		displayList.remove(task);
		return result;
	}
	
	public static boolean markDone(Task task) throws IOException {
		boolean result = GrandTaskList.markDone(task);
		displayList.remove(task);
		return result;
	}
	
	public static boolean unmarkDone(Task task) throws IOException {
		boolean result = GrandTaskList.unmarkDone(task);
		return result;
	}
	
	public static void displayAllTasks() {
		displayList.clear();
		for (Task task: GrandTaskList.getTotalList()) {
			displayList.add(task);
		}
	}
	
	public static void displayFloatTasks() {
		displayList.clear();
		for (Task task: GrandTaskList.getFloatList()) {
			displayList.add(task);
		}
	}
	
	public static void displayDeadlines() {
		displayList.clear();
		for (Task task: GrandTaskList.getDeadlineList()) {
			displayList.add(task);
		}
	}
	
	public static void displaySessions() {
		displayList.clear();
		for (Task task: GrandTaskList.getSessionList()) {
			displayList.add(task);
		}
	}
	
	public static void displayRecurring() {
		displayList.clear();
		for (Task task: GrandTaskList.getRecurringList()) {
			displayList.add(task);
		}
	}
	
	public static void displayTasksOnDate(Calendar date) {
		displayList.clear();
		for (Task task: GrandTaskList.getTasksOnDate(date)) {
			displayList.add(task);
		}
	}
	
	public static void displayUndoneList() {
		displayList.clear();
		for (Task task: GrandTaskList.getUndoneList()) {
			displayList.add(task);
		}
	}
	
	public static void displayUpcomingList() {
		displayList.clear();
		for (Task task: GrandTaskList.getUpcomingList()) {
			displayList.add(task);
		}
	}
	
	public static void displayDoneList() {
		displayList.clear();
		for (Task task: GrandTaskList.getDoneList()) {
			displayList.add(task);
		}
	}
	
	public static void clearDisplayedTasks() throws IOException {
		for (Task task: displayList) {
			GrandTaskList.deleteTask(task);
		}
		displayList.clear();
	}
	
	public static void clearAllTasks() throws IOException {
		GrandTaskList.clearAll();
		displayList.clear();
	}
	
	public static void setPath(String pathName) throws IOException {
		Database.setPath(pathName);
	}
	
	public static String getPath() {
		return Database.getPath();
	}
	
	public static void searchTask(Predicate<Task> predicate) {
		displayList.clear();
		for (Task task: GrandTaskList.search(predicate)) {
			displayList.add(task);
		}
	}
	
	public static ArrayList<Task> getTimelineList() {
		ArrayList<Task> result = new ArrayList<Task>();
		for (Task task: GrandTaskList.getNoRecurringList()) {
			Calendar date = task.getStartDate();
			Calendar nextOneMonth = Calendar.getInstance();
			nextOneMonth.add(Calendar.DATE, 30);
			if (date != null
				&& DateUtils.truncatedCompareTo(date,
						nextOneMonth,
						Calendar.DATE) < 0) {
				result.add(task);
			}
		}
		return result;
	}
}
```
###### src\storage\StorageLogger.java
``` java
 * Logger for Logic
 */
import java.util.logging.Level;
import java.util.logging.Logger;

public class StorageLogger {
	
	public static Logger storageLogger;
	
	public static void initialize() {
		storageLogger = Logger.getLogger("StorageLogger");
	}
	
	public static void log(Level level, String message) {
		storageLogger.log(level, message);
	}
}
```
###### src\storage\TaskList.java
``` java
 * This class contains the lists of specific types of tasks
 */
public class TaskList<T extends Task> implements Iterable<T> {
	
	private SortedSet<T> taskList;
	
	public TaskList() {
		taskList = new TreeSet<T>(new TaskUtil.TaskComparator());
	}
	
	public Iterator<T> iterator() {
		return taskList.iterator();
	}
	
	public SortedSet<T> getInternalList() {
		return taskList;
	}
	
	public boolean add(T task) {
		return taskList.add(task);
	}
	
	public boolean addAll(TaskList<T> addedList) {
		return taskList.addAll(addedList.getInternalList());
	}
	
	public boolean delete(T task) {
		return taskList.remove(task);
	}
	
	public int size() {
		return taskList.size();
	}
	
	public TaskList<T> search(Predicate<T> predicate) {
		TaskList<T> results = new TaskList<T>();
		for (T task: taskList) {
			if (predicate.test(task)) {
				results.add(task);
			}
		}
		return results;
	}
	
	public TaskList<Task> search(TaskList<Task> results, Predicate<Task> predicate) {
		for (T task: taskList) {
			if (predicate.test(task)) {
				results.add(task);
			}
		}
		return results;
	}

	public ArrayList<Task> search(ArrayList<Task> results, Predicate<Task> predicate) {
		for (T task: taskList) {
			if (predicate.test(task)) {
				results.add(task);
			}
		}
		return results;
	}
	
	public void merge(TaskList<Task> result) {
		for (Task task: taskList) {
			result.add(task);
		}
	}
	
	public void clear() {
		taskList.clear();
	}
}
```
###### Test\logic\TestAdd.java
``` java
 * This class tests add feature of the Logic
 */
public class TestAdd {
	
	@Test
	public void testAdd() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		ArrayList<String> taskList = new ArrayList<String>();
		taskList.add(task.toString());
		Response addResponse = new Response("Task added successfully", taskList);
		assertEquals(addResponse.toString(), TaskProcessor.executeCommand(commandAdd).toString());
	}
	
}
```
###### Test\logic\TestAddUndo.java
``` java
 * this class tests the undo method of Add
 */
import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandUndo;
import logic.tasks.Deadline;
import storage.Storage;

public class TestAddUndo {
	
	@Test
	public void testAdd() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		TaskProcessor.executeCommand(commandAdd);
		Command commandUndo = new CommandUndo();
		ArrayList<String> taskList = new ArrayList<String>();
		Response undoResponse = new Response("Command undone successfully", taskList);
		assertEquals(undoResponse, TaskProcessor.executeCommand(commandUndo));
	}
}
```
###### Test\logic\TestDelete.java
``` java
 * This class tests the delete feature of Logic
 */
import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandDelete;
import logic.tasks.Deadline;
import storage.Storage;

public class TestDelete {
	
	@Test
	public void testDelete() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		TaskProcessor.executeCommand(commandAdd);
		Command commandDelete = new CommandDelete(1);
		ArrayList<String> taskList = new ArrayList<String>();
		assertEquals(taskList, TaskProcessor.executeCommand(commandDelete));
	}
}
```
###### Test\logic\TestDeleteUndo.java
``` java
 * This class tests the undo method of Delete
 */

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import logic.commands.Command;
import logic.commands.CommandAdd;
import logic.commands.CommandDelete;
import logic.commands.CommandUndo;
import logic.tasks.Deadline;
import storage.Storage;

public class TestDeleteUndo {
	
	@Test
	public void testAdd() {
		Deadline task = new Deadline("go tutorial", new Date());
		Command commandAdd = new CommandAdd(task);
		TaskProcessor.initialize();
		Storage.clearAllTasks();
		TaskProcessor.executeCommand(commandAdd);
		Command commandDelete = new CommandDelete(1);
		TaskProcessor.executeCommand(commandDelete);
		Command commandUndo = new CommandUndo();
		ArrayList<String> taskList = new ArrayList<String>();
		taskList.add(task.toString());
		Response undoResponse = new Response("Command undone successfully", taskList);
		assertEquals(undoResponse, TaskProcessor.executeCommand(commandUndo));
	}
}
```
